/*
 * generated by Xtext 2.14.0
 */
package edu.ustb.sei.mde.bxcore.dsl.serializer;

import com.google.inject.Inject;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXCorePackage;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXFunctionDefinition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXProgram;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BiGULReplace;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BiGULSkip;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.ContextAwareCondition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.ContextAwareUnidirectionalAction;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.Conversion;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.DefinedContextTypeRef;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.EcoreTypeRef;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.EmptyContextTypeRef;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.FeatureTypeRef;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.ImportSection;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.IndexDefinition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.IndexPart;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternDefinition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternDefinitionReference;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternEdge;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternNode;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternNodeRef;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PrimitiveTypeRef;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeDefinition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeVar;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.VarMapping;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreAlign;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreExpandSource;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreExpandView;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreFork;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreForkBranch;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreFunctionCall;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreGraphReplace;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreIndex;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreMatchSource;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreMatchView;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreParallelComposition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreSwitch;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreSwitchAdaption;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreSwitchBranch;
import edu.ustb.sei.mde.bxcore.dsl.services.BXCoreGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.common.types.JvmFormalParameter;
import org.eclipse.xtext.common.types.JvmGenericArrayTypeReference;
import org.eclipse.xtext.common.types.JvmInnerTypeReference;
import org.eclipse.xtext.common.types.JvmLowerBound;
import org.eclipse.xtext.common.types.JvmParameterizedTypeReference;
import org.eclipse.xtext.common.types.JvmTypeParameter;
import org.eclipse.xtext.common.types.JvmUpperBound;
import org.eclipse.xtext.common.types.JvmWildcardTypeReference;
import org.eclipse.xtext.common.types.TypesPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.eclipse.xtext.xbase.XAssignment;
import org.eclipse.xtext.xbase.XBasicForLoopExpression;
import org.eclipse.xtext.xbase.XBinaryOperation;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XBooleanLiteral;
import org.eclipse.xtext.xbase.XCasePart;
import org.eclipse.xtext.xbase.XCastedExpression;
import org.eclipse.xtext.xbase.XCatchClause;
import org.eclipse.xtext.xbase.XClosure;
import org.eclipse.xtext.xbase.XConstructorCall;
import org.eclipse.xtext.xbase.XDoWhileExpression;
import org.eclipse.xtext.xbase.XFeatureCall;
import org.eclipse.xtext.xbase.XForLoopExpression;
import org.eclipse.xtext.xbase.XIfExpression;
import org.eclipse.xtext.xbase.XInstanceOfExpression;
import org.eclipse.xtext.xbase.XListLiteral;
import org.eclipse.xtext.xbase.XMemberFeatureCall;
import org.eclipse.xtext.xbase.XNullLiteral;
import org.eclipse.xtext.xbase.XNumberLiteral;
import org.eclipse.xtext.xbase.XPostfixOperation;
import org.eclipse.xtext.xbase.XReturnExpression;
import org.eclipse.xtext.xbase.XSetLiteral;
import org.eclipse.xtext.xbase.XStringLiteral;
import org.eclipse.xtext.xbase.XSwitchExpression;
import org.eclipse.xtext.xbase.XSynchronizedExpression;
import org.eclipse.xtext.xbase.XThrowExpression;
import org.eclipse.xtext.xbase.XTryCatchFinallyExpression;
import org.eclipse.xtext.xbase.XTypeLiteral;
import org.eclipse.xtext.xbase.XUnaryOperation;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.XWhileExpression;
import org.eclipse.xtext.xbase.XbasePackage;
import org.eclipse.xtext.xbase.serializer.XbaseSemanticSequencer;
import org.eclipse.xtext.xtype.XFunctionTypeRef;
import org.eclipse.xtext.xtype.XImportDeclaration;
import org.eclipse.xtext.xtype.XImportSection;
import org.eclipse.xtext.xtype.XtypePackage;

@SuppressWarnings("all")
public class BXCoreSemanticSequencer extends XbaseSemanticSequencer {

	@Inject
	private BXCoreGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BXCorePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BXCorePackage.BX_FUNCTION_DEFINITION:
				sequence_BXFunctionDefinition(context, (BXFunctionDefinition) semanticObject); 
				return; 
			case BXCorePackage.BX_PROGRAM:
				sequence_BXProgram(context, (BXProgram) semanticObject); 
				return; 
			case BXCorePackage.BI_GUL_REPLACE:
				sequence_BiGULReplace(context, (BiGULReplace) semanticObject); 
				return; 
			case BXCorePackage.BI_GUL_SKIP:
				sequence_BiGULSkip(context, (BiGULSkip) semanticObject); 
				return; 
			case BXCorePackage.CONTEXT_AWARE_CONDITION:
				sequence_ContextAwareCondition(context, (ContextAwareCondition) semanticObject); 
				return; 
			case BXCorePackage.CONTEXT_AWARE_UNIDIRECTIONAL_ACTION:
				sequence_ContextAwareUnidirectionalAction(context, (ContextAwareUnidirectionalAction) semanticObject); 
				return; 
			case BXCorePackage.CONVERSION:
				sequence_Conversion(context, (Conversion) semanticObject); 
				return; 
			case BXCorePackage.DEFINED_CONTEXT_TYPE_REF:
				sequence_ContextTypeRef(context, (DefinedContextTypeRef) semanticObject); 
				return; 
			case BXCorePackage.ECORE_TYPE_REF:
				sequence_TypeRef(context, (EcoreTypeRef) semanticObject); 
				return; 
			case BXCorePackage.EMPTY_CONTEXT_TYPE_REF:
				sequence_ContextTypeRef(context, (EmptyContextTypeRef) semanticObject); 
				return; 
			case BXCorePackage.FEATURE_TYPE_REF:
				sequence_TypeRef(context, (FeatureTypeRef) semanticObject); 
				return; 
			case BXCorePackage.IMPORT_SECTION:
				sequence_ImportSection(context, (ImportSection) semanticObject); 
				return; 
			case BXCorePackage.INDEX_DEFINITION:
				sequence_IndexDefinition(context, (IndexDefinition) semanticObject); 
				return; 
			case BXCorePackage.INDEX_PART:
				sequence_IndexPart(context, (IndexPart) semanticObject); 
				return; 
			case BXCorePackage.PATTERN_DEFINITION:
				if (rule == grammarAccess.getAnonymousPatternDefinitionRule()
						|| rule == grammarAccess.getPatternRule()
						|| rule == grammarAccess.getContextTypeRule()) {
					sequence_AnonymousPatternDefinition(context, (PatternDefinition) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDefinitionRule()
						|| rule == grammarAccess.getPatternDefinitionRule()) {
					sequence_PatternDefinition(context, (PatternDefinition) semanticObject); 
					return; 
				}
				else break;
			case BXCorePackage.PATTERN_DEFINITION_REFERENCE:
				sequence_PatternDefinitionReference(context, (PatternDefinitionReference) semanticObject); 
				return; 
			case BXCorePackage.PATTERN_EDGE:
				sequence_PatternEdge(context, (PatternEdge) semanticObject); 
				return; 
			case BXCorePackage.PATTERN_NODE:
				sequence_PatternNode(context, (PatternNode) semanticObject); 
				return; 
			case BXCorePackage.PATTERN_NODE_REF:
				sequence_PatternNodeRef(context, (PatternNodeRef) semanticObject); 
				return; 
			case BXCorePackage.PRIMITIVE_TYPE_REF:
				sequence_TypeRef(context, (PrimitiveTypeRef) semanticObject); 
				return; 
			case BXCorePackage.TYPE_DEFINITION:
				sequence_TypeDefinition(context, (TypeDefinition) semanticObject); 
				return; 
			case BXCorePackage.TYPE_VAR:
				sequence_TypeVar(context, (TypeVar) semanticObject); 
				return; 
			case BXCorePackage.VAR_MAPPING:
				sequence_VarMapping(context, (VarMapping) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_ALIGN:
				sequence_XmuCoreAlign(context, (XmuCoreAlign) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_EXPAND_SOURCE:
				sequence_XmuCoreExpandSource(context, (XmuCoreExpandSource) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_EXPAND_VIEW:
				sequence_XmuCoreExpandView(context, (XmuCoreExpandView) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_FORK:
				sequence_XmuCoreFork(context, (XmuCoreFork) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_FORK_BRANCH:
				sequence_XmuCoreForkBranch(context, (XmuCoreForkBranch) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_FUNCTION_CALL:
				sequence_XmuCoreFunctionCall(context, (XmuCoreFunctionCall) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_GRAPH_REPLACE:
				sequence_XmuCoreGraphReplace(context, (XmuCoreGraphReplace) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_INDEX:
				sequence_XmuCoreIndex(context, (XmuCoreIndex) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_MATCH_SOURCE:
				sequence_XmuCoreMatchSource(context, (XmuCoreMatchSource) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_MATCH_VIEW:
				sequence_XmuCoreMatchView(context, (XmuCoreMatchView) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_PARALLEL_COMPOSITION:
				sequence_XmuCoreParallelComposition(context, (XmuCoreParallelComposition) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_SWITCH:
				sequence_XmuCoreSwitch(context, (XmuCoreSwitch) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_SWITCH_ADAPTION:
				sequence_XmuCoreSwitchAdaption(context, (XmuCoreSwitchAdaption) semanticObject); 
				return; 
			case BXCorePackage.XMU_CORE_SWITCH_BRANCH:
				sequence_XmuCoreSwitchBranch(context, (XmuCoreSwitchBranch) semanticObject); 
				return; 
			}
		else if (epackage == TypesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TypesPackage.JVM_FORMAL_PARAMETER:
				if (rule == grammarAccess.getFullJvmFormalParameterRule()) {
					sequence_FullJvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmFormalParameterRule()) {
					sequence_JvmFormalParameter(context, (JvmFormalParameter) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_GENERIC_ARRAY_TYPE_REFERENCE:
				sequence_JvmTypeReference(context, (JvmGenericArrayTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_INNER_TYPE_REFERENCE:
				sequence_JvmParameterizedTypeReference(context, (JvmInnerTypeReference) semanticObject); 
				return; 
			case TypesPackage.JVM_LOWER_BOUND:
				if (rule == grammarAccess.getJvmLowerBoundAndedRule()) {
					sequence_JvmLowerBoundAnded(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmLowerBoundRule()) {
					sequence_JvmLowerBound(context, (JvmLowerBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_PARAMETERIZED_TYPE_REFERENCE:
				if (action == grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0()) {
					sequence_JvmParameterizedTypeReference_JvmInnerTypeReference_1_4_0_0_0(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmTypeReferenceRule()
						|| action == grammarAccess.getJvmTypeReferenceAccess().getJvmGenericArrayTypeReferenceComponentTypeAction_0_1_0_0()
						|| rule == grammarAccess.getJvmParameterizedTypeReferenceRule()
						|| rule == grammarAccess.getJvmArgumentTypeReferenceRule()) {
					sequence_JvmParameterizedTypeReference(context, (JvmParameterizedTypeReference) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_TYPE_PARAMETER:
				sequence_JvmTypeParameter(context, (JvmTypeParameter) semanticObject); 
				return; 
			case TypesPackage.JVM_UPPER_BOUND:
				if (rule == grammarAccess.getJvmUpperBoundAndedRule()) {
					sequence_JvmUpperBoundAnded(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getJvmUpperBoundRule()) {
					sequence_JvmUpperBound(context, (JvmUpperBound) semanticObject); 
					return; 
				}
				else break;
			case TypesPackage.JVM_WILDCARD_TYPE_REFERENCE:
				sequence_JvmWildcardTypeReference(context, (JvmWildcardTypeReference) semanticObject); 
				return; 
			}
		else if (epackage == XbasePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XbasePackage.XASSIGNMENT:
				sequence_XAssignment_XMemberFeatureCall(context, (XAssignment) semanticObject); 
				return; 
			case XbasePackage.XBASIC_FOR_LOOP_EXPRESSION:
				sequence_XBasicForLoopExpression(context, (XBasicForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XBINARY_OPERATION:
				sequence_XAdditiveExpression_XAndExpression_XAssignment_XEqualityExpression_XMultiplicativeExpression_XOrExpression_XOtherOperatorExpression_XRelationalExpression(context, (XBinaryOperation) semanticObject); 
				return; 
			case XbasePackage.XBLOCK_EXPRESSION:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXBlockExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XBlockExpression(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXExpressionInClosureRule()) {
					sequence_XExpressionInClosure(context, (XBlockExpression) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XBOOLEAN_LITERAL:
				sequence_XBooleanLiteral(context, (XBooleanLiteral) semanticObject); 
				return; 
			case XbasePackage.XCASE_PART:
				sequence_XCasePart(context, (XCasePart) semanticObject); 
				return; 
			case XbasePackage.XCASTED_EXPRESSION:
				sequence_XCastedExpression(context, (XCastedExpression) semanticObject); 
				return; 
			case XbasePackage.XCATCH_CLAUSE:
				sequence_XCatchClause(context, (XCatchClause) semanticObject); 
				return; 
			case XbasePackage.XCLOSURE:
				if (rule == grammarAccess.getXExpressionRule()
						|| rule == grammarAccess.getXAssignmentRule()
						|| action == grammarAccess.getXAssignmentAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOrExpressionRule()
						|| action == grammarAccess.getXOrExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAndExpressionRule()
						|| action == grammarAccess.getXAndExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXEqualityExpressionRule()
						|| action == grammarAccess.getXEqualityExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXRelationalExpressionRule()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXInstanceOfExpressionExpressionAction_1_0_0_0_0()
						|| action == grammarAccess.getXRelationalExpressionAccess().getXBinaryOperationLeftOperandAction_1_1_0_0_0()
						|| rule == grammarAccess.getXOtherOperatorExpressionRule()
						|| action == grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXAdditiveExpressionRule()
						|| action == grammarAccess.getXAdditiveExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXMultiplicativeExpressionRule()
						|| action == grammarAccess.getXMultiplicativeExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0()
						|| rule == grammarAccess.getXUnaryOperationRule()
						|| rule == grammarAccess.getXCastedExpressionRule()
						|| action == grammarAccess.getXCastedExpressionAccess().getXCastedExpressionTargetAction_1_0_0_0()
						|| rule == grammarAccess.getXPostfixOperationRule()
						|| action == grammarAccess.getXPostfixOperationAccess().getXPostfixOperationOperandAction_1_0_0()
						|| rule == grammarAccess.getXMemberFeatureCallRule()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXAssignmentAssignableAction_1_0_0_0_0()
						|| action == grammarAccess.getXMemberFeatureCallAccess().getXMemberFeatureCallMemberCallTargetAction_1_1_0_0_0()
						|| rule == grammarAccess.getXPrimaryExpressionRule()
						|| rule == grammarAccess.getXLiteralRule()
						|| rule == grammarAccess.getXClosureRule()
						|| rule == grammarAccess.getXParenthesizedExpressionRule()
						|| rule == grammarAccess.getXExpressionOrVarDeclarationRule()) {
					sequence_XClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getXShortClosureRule()) {
					sequence_XShortClosure(context, (XClosure) semanticObject); 
					return; 
				}
				else break;
			case XbasePackage.XCONSTRUCTOR_CALL:
				sequence_XConstructorCall(context, (XConstructorCall) semanticObject); 
				return; 
			case XbasePackage.XDO_WHILE_EXPRESSION:
				sequence_XDoWhileExpression(context, (XDoWhileExpression) semanticObject); 
				return; 
			case XbasePackage.XFEATURE_CALL:
				sequence_XFeatureCall(context, (XFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XFOR_LOOP_EXPRESSION:
				sequence_XForLoopExpression(context, (XForLoopExpression) semanticObject); 
				return; 
			case XbasePackage.XIF_EXPRESSION:
				sequence_XIfExpression(context, (XIfExpression) semanticObject); 
				return; 
			case XbasePackage.XINSTANCE_OF_EXPRESSION:
				sequence_XRelationalExpression(context, (XInstanceOfExpression) semanticObject); 
				return; 
			case XbasePackage.XLIST_LITERAL:
				sequence_XListLiteral(context, (XListLiteral) semanticObject); 
				return; 
			case XbasePackage.XMEMBER_FEATURE_CALL:
				sequence_XMemberFeatureCall(context, (XMemberFeatureCall) semanticObject); 
				return; 
			case XbasePackage.XNULL_LITERAL:
				sequence_XNullLiteral(context, (XNullLiteral) semanticObject); 
				return; 
			case XbasePackage.XNUMBER_LITERAL:
				sequence_XNumberLiteral(context, (XNumberLiteral) semanticObject); 
				return; 
			case XbasePackage.XPOSTFIX_OPERATION:
				sequence_XPostfixOperation(context, (XPostfixOperation) semanticObject); 
				return; 
			case XbasePackage.XRETURN_EXPRESSION:
				sequence_XReturnExpression(context, (XReturnExpression) semanticObject); 
				return; 
			case XbasePackage.XSET_LITERAL:
				sequence_XSetLiteral(context, (XSetLiteral) semanticObject); 
				return; 
			case XbasePackage.XSTRING_LITERAL:
				sequence_XStringLiteral(context, (XStringLiteral) semanticObject); 
				return; 
			case XbasePackage.XSWITCH_EXPRESSION:
				sequence_XSwitchExpression(context, (XSwitchExpression) semanticObject); 
				return; 
			case XbasePackage.XSYNCHRONIZED_EXPRESSION:
				sequence_XSynchronizedExpression(context, (XSynchronizedExpression) semanticObject); 
				return; 
			case XbasePackage.XTHROW_EXPRESSION:
				sequence_XThrowExpression(context, (XThrowExpression) semanticObject); 
				return; 
			case XbasePackage.XTRY_CATCH_FINALLY_EXPRESSION:
				sequence_XTryCatchFinallyExpression(context, (XTryCatchFinallyExpression) semanticObject); 
				return; 
			case XbasePackage.XTYPE_LITERAL:
				sequence_XTypeLiteral(context, (XTypeLiteral) semanticObject); 
				return; 
			case XbasePackage.XUNARY_OPERATION:
				sequence_XUnaryOperation(context, (XUnaryOperation) semanticObject); 
				return; 
			case XbasePackage.XVARIABLE_DECLARATION:
				sequence_XVariableDeclaration(context, (XVariableDeclaration) semanticObject); 
				return; 
			case XbasePackage.XWHILE_EXPRESSION:
				sequence_XWhileExpression(context, (XWhileExpression) semanticObject); 
				return; 
			}
		else if (epackage == XtypePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtypePackage.XFUNCTION_TYPE_REF:
				sequence_XFunctionTypeRef(context, (XFunctionTypeRef) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_DECLARATION:
				sequence_XImportDeclaration(context, (XImportDeclaration) semanticObject); 
				return; 
			case XtypePackage.XIMPORT_SECTION:
				sequence_XImportSection(context, (XImportSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AnonymousPatternDefinition returns PatternDefinition
	 *     Pattern returns PatternDefinition
	 *     ContextType returns PatternDefinition
	 *
	 * Constraint:
	 *     (root=PatternNode type=ValidID?)
	 */
	protected void sequence_AnonymousPatternDefinition(ISerializationContext context, PatternDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns BXFunctionDefinition
	 *     BXFunctionDefinition returns BXFunctionDefinition
	 *
	 * Constraint:
	 *     (name=ValidID sourceType=ContextTypeRef viewType=ContextTypeRef statement=XmuCoreStatement)
	 */
	protected void sequence_BXFunctionDefinition(ISerializationContext context, BXFunctionDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.BX_FUNCTION_DEFINITION__SOURCE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.BX_FUNCTION_DEFINITION__SOURCE_TYPE));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.BX_FUNCTION_DEFINITION__VIEW_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.BX_FUNCTION_DEFINITION__VIEW_TYPE));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.BX_FUNCTION_DEFINITION__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.BX_FUNCTION_DEFINITION__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBXFunctionDefinitionAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBXFunctionDefinitionAccess().getSourceTypeContextTypeRefParserRuleCall_3_0(), semanticObject.getSourceType());
		feeder.accept(grammarAccess.getBXFunctionDefinitionAccess().getViewTypeContextTypeRefParserRuleCall_5_0(), semanticObject.getViewType());
		feeder.accept(grammarAccess.getBXFunctionDefinitionAccess().getStatementXmuCoreStatementParserRuleCall_8_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BXProgram returns BXProgram
	 *
	 * Constraint:
	 *     (
	 *         (imports+=ImportSection* javaImports=XImportSection definitions+=Definition+) | 
	 *         (imports+=ImportSection* definitions+=Definition+) | 
	 *         definitions+=Definition+
	 *     )?
	 */
	protected void sequence_BXProgram(ISerializationContext context, BXProgram semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BiGULStatement returns BiGULReplace
	 *     BiGULReplace returns BiGULReplace
	 *
	 * Constraint:
	 *     {BiGULReplace}
	 */
	protected void sequence_BiGULReplace(ISerializationContext context, BiGULReplace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BiGULStatement returns BiGULSkip
	 *     BiGULSkip returns BiGULSkip
	 *
	 * Constraint:
	 *     {BiGULSkip}
	 */
	protected void sequence_BiGULSkip(ISerializationContext context, BiGULSkip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextAwareCondition returns ContextAwareCondition
	 *
	 * Constraint:
	 *     condition=XExpression
	 */
	protected void sequence_ContextAwareCondition(ISerializationContext context, ContextAwareCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.CONTEXT_AWARE_CONDITION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.CONTEXT_AWARE_CONDITION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextAwareConditionAccess().getConditionXExpressionParserRuleCall_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContextAwareUnidirectionalAction returns ContextAwareUnidirectionalAction
	 *
	 * Constraint:
	 *     action=XBlockExpression
	 */
	protected void sequence_ContextAwareUnidirectionalAction(ISerializationContext context, ContextAwareUnidirectionalAction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.CONTEXT_AWARE_UNIDIRECTIONAL_ACTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.CONTEXT_AWARE_UNIDIRECTIONAL_ACTION__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextAwareUnidirectionalActionAccess().getActionXBlockExpressionParserRuleCall_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContextTypeRef returns DefinedContextTypeRef
	 *
	 * Constraint:
	 *     type=[ContextType|ValidID]
	 */
	protected void sequence_ContextTypeRef(ISerializationContext context, DefinedContextTypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.DEFINED_CONTEXT_TYPE_REF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.DEFINED_CONTEXT_TYPE_REF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextTypeRefAccess().getTypeContextTypeValidIDParserRuleCall_0_1_0_1(), semanticObject.eGet(BXCorePackage.Literals.DEFINED_CONTEXT_TYPE_REF__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContextTypeRef returns EmptyContextTypeRef
	 *
	 * Constraint:
	 *     {EmptyContextTypeRef}
	 */
	protected void sequence_ContextTypeRef(ISerializationContext context, EmptyContextTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Conversion returns Conversion
	 *
	 * Constraint:
	 *     (bigul=BiGULStatement source+=ValidID source+=ValidID* view+=ValidID view+=ValidID*)
	 */
	protected void sequence_Conversion(ISerializationContext context, Conversion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportSection returns ImportSection
	 *
	 * Constraint:
	 *     (metamodel=[EPackage|STRING] shortName=ValidID)
	 */
	protected void sequence_ImportSection(ISerializationContext context, ImportSection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.IMPORT_SECTION__METAMODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.IMPORT_SECTION__METAMODEL));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.IMPORT_SECTION__SHORT_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.IMPORT_SECTION__SHORT_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportSectionAccess().getMetamodelEPackageSTRINGTerminalRuleCall_1_0_1(), semanticObject.eGet(BXCorePackage.Literals.IMPORT_SECTION__METAMODEL, false));
		feeder.accept(grammarAccess.getImportSectionAccess().getShortNameValidIDParserRuleCall_3_0(), semanticObject.getShortName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns IndexDefinition
	 *     IndexDefinition returns IndexDefinition
	 *
	 * Constraint:
	 *     (name=ValidID sourceType=ContextTypeRef viewType=ContextTypeRef)
	 */
	protected void sequence_IndexDefinition(ISerializationContext context, IndexDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.DEFINITION__NAME));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.INDEX_DEFINITION__SOURCE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.INDEX_DEFINITION__SOURCE_TYPE));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.INDEX_DEFINITION__VIEW_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.INDEX_DEFINITION__VIEW_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIndexDefinitionAccess().getNameValidIDParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getIndexDefinitionAccess().getSourceTypeContextTypeRefParserRuleCall_3_0(), semanticObject.getSourceType());
		feeder.accept(grammarAccess.getIndexDefinitionAccess().getViewTypeContextTypeRefParserRuleCall_5_0(), semanticObject.getViewType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IndexPart returns IndexPart
	 *
	 * Constraint:
	 *     (signature=[IndexDefinition|ValidID] sourceKeys+=ValidID sourceKeys+=ValidID* viewKeys+=ValidID viewKeys+=ValidID*)
	 */
	protected void sequence_IndexPart(ISerializationContext context, IndexPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns PatternDefinitionReference
	 *     PatternDefinitionReference returns PatternDefinitionReference
	 *
	 * Constraint:
	 *     pattern=[PatternDefinition|ValidID]
	 */
	protected void sequence_PatternDefinitionReference(ISerializationContext context, PatternDefinitionReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.PATTERN_DEFINITION_REFERENCE__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.PATTERN_DEFINITION_REFERENCE__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternDefinitionReferenceAccess().getPatternPatternDefinitionValidIDParserRuleCall_0_1(), semanticObject.eGet(BXCorePackage.Literals.PATTERN_DEFINITION_REFERENCE__PATTERN, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns PatternDefinition
	 *     PatternDefinition returns PatternDefinition
	 *
	 * Constraint:
	 *     (name=ValidID root=PatternNode type=ValidID?)
	 */
	protected void sequence_PatternDefinition(ISerializationContext context, PatternDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternEdge returns PatternEdge
	 *
	 * Constraint:
	 *     (name=ValidID? feature=[EStructuralFeature|ValidID] operator='=' value=PatternValueCondition)
	 */
	protected void sequence_PatternEdge(ISerializationContext context, PatternEdge semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternValueCondition returns PatternNodeRef
	 *     PatternNodeRef returns PatternNodeRef
	 *
	 * Constraint:
	 *     node=[PatternNode|ValidID]
	 */
	protected void sequence_PatternNodeRef(ISerializationContext context, PatternNodeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.PATTERN_NODE_REF__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.PATTERN_NODE_REF__NODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternNodeRefAccess().getNodePatternNodeValidIDParserRuleCall_0_1(), semanticObject.eGet(BXCorePackage.Literals.PATTERN_NODE_REF__NODE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternNode returns PatternNode
	 *     PatternValueCondition returns PatternNode
	 *
	 * Constraint:
	 *     (name=ValidID type=TypeRef (edges+=PatternEdge edges+=PatternEdge*)?)
	 */
	protected void sequence_PatternNode(ISerializationContext context, PatternNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns TypeDefinition
	 *     TypeDefinition returns TypeDefinition
	 *     ContextType returns TypeDefinition
	 *
	 * Constraint:
	 *     (name=ValidID (typeVars+=TypeVar typeVars+=TypeVar*)?)
	 */
	protected void sequence_TypeDefinition(ISerializationContext context, TypeDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns EcoreTypeRef
	 *
	 * Constraint:
	 *     type=[EClassifier|QualifiedValidID]
	 */
	protected void sequence_TypeRef(ISerializationContext context, EcoreTypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.ECORE_TYPE_REF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.ECORE_TYPE_REF__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeRefAccess().getTypeEClassifierQualifiedValidIDParserRuleCall_0_1_0_1(), semanticObject.eGet(BXCorePackage.Literals.ECORE_TYPE_REF__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns FeatureTypeRef
	 *
	 * Constraint:
	 *     (type=[EClassifier|QualifiedValidID] feature=[EStructuralFeature|ValidID])
	 */
	protected void sequence_TypeRef(ISerializationContext context, FeatureTypeRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.FEATURE_TYPE_REF__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.FEATURE_TYPE_REF__TYPE));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.FEATURE_TYPE_REF__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.FEATURE_TYPE_REF__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeRefAccess().getTypeEClassifierQualifiedValidIDParserRuleCall_1_1_0_1(), semanticObject.eGet(BXCorePackage.Literals.FEATURE_TYPE_REF__TYPE, false));
		feeder.accept(grammarAccess.getTypeRefAccess().getFeatureEStructuralFeatureValidIDParserRuleCall_1_2_1_0_1(), semanticObject.eGet(BXCorePackage.Literals.FEATURE_TYPE_REF__FEATURE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeRef returns PrimitiveTypeRef
	 *
	 * Constraint:
	 *     (type='int' | type='boolean' | type='String')
	 */
	protected void sequence_TypeRef(ISerializationContext context, PrimitiveTypeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeVar returns TypeVar
	 *
	 * Constraint:
	 *     (name=ValidID type=TypeRef)
	 */
	protected void sequence_TypeVar(ISerializationContext context, TypeVar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.TYPE_VAR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.TYPE_VAR__NAME));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.TYPE_VAR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.TYPE_VAR__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeVarAccess().getNameValidIDParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTypeVarAccess().getTypeTypeRefParserRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarMapping returns VarMapping
	 *
	 * Constraint:
	 *     (from=ValidID to=ValidID)
	 */
	protected void sequence_VarMapping(ISerializationContext context, VarMapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.VAR_MAPPING__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.VAR_MAPPING__FROM));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.VAR_MAPPING__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.VAR_MAPPING__TO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarMappingAccess().getFromValidIDParserRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getVarMappingAccess().getToValidIDParserRuleCall_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreAlign
	 *     XmuCoreCompositionChildStatement returns XmuCoreAlign
	 *     XmuCoreAlign returns XmuCoreAlign
	 *
	 * Constraint:
	 *     (
	 *         sourceType=ContextTypeRef 
	 *         viewType=ContextTypeRef 
	 *         sourcePattern=Pattern 
	 *         viewPattern=Pattern 
	 *         alignment=ContextAwareCondition 
	 *         (match=XmuCoreStatement | unmatchS=ContextAwareUnidirectionalAction | unmatchV=ContextAwareUnidirectionalAction)+
	 *     )
	 */
	protected void sequence_XmuCoreAlign(ISerializationContext context, XmuCoreAlign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreExpandSource
	 *     XmuCoreCompositionChildStatement returns XmuCoreExpandSource
	 *     XmuCoreExpandSource returns XmuCoreExpandSource
	 *
	 * Constraint:
	 *     (pattern=Pattern mappings+=VarMapping mappings+=VarMapping* body=XmuCoreStatement)
	 */
	protected void sequence_XmuCoreExpandSource(ISerializationContext context, XmuCoreExpandSource semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreExpandView
	 *     XmuCoreCompositionChildStatement returns XmuCoreExpandView
	 *     XmuCoreExpandView returns XmuCoreExpandView
	 *
	 * Constraint:
	 *     (pattern=Pattern mappings+=VarMapping mappings+=VarMapping* body=XmuCoreStatement)
	 */
	protected void sequence_XmuCoreExpandView(ISerializationContext context, XmuCoreExpandView semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreForkBranch returns XmuCoreForkBranch
	 *
	 * Constraint:
	 *     (sourceMappings+=VarMapping sourceMappings+=VarMapping* viewMappings+=VarMapping viewMappings+=VarMapping* body=XmuCoreStatement)
	 */
	protected void sequence_XmuCoreForkBranch(ISerializationContext context, XmuCoreForkBranch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreFork
	 *     XmuCoreFork returns XmuCoreFork
	 *
	 * Constraint:
	 *     (sourceType=ContextTypeRef viewType=ContextTypeRef forks+=XmuCoreForkBranch forks+=XmuCoreForkBranch+)
	 */
	protected void sequence_XmuCoreFork(ISerializationContext context, XmuCoreFork semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreFunctionCall
	 *     XmuCoreCompositionChildStatement returns XmuCoreFunctionCall
	 *     XmuCoreFunctionCall returns XmuCoreFunctionCall
	 *
	 * Constraint:
	 *     (sourceMappings+=VarMapping sourceMappings+=VarMapping* viewMappings+=VarMapping viewMappings+=VarMapping* target=[BXFunctionDefinition|ValidID])
	 */
	protected void sequence_XmuCoreFunctionCall(ISerializationContext context, XmuCoreFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreGraphReplace
	 *     XmuCoreCompositionChildStatement returns XmuCoreGraphReplace
	 *     XmuCoreGraphReplace returns XmuCoreGraphReplace
	 *
	 * Constraint:
	 *     (source=Pattern view=Pattern conversions+=Conversion+)
	 */
	protected void sequence_XmuCoreGraphReplace(ISerializationContext context, XmuCoreGraphReplace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreIndex
	 *     XmuCoreCompositionChildStatement returns XmuCoreIndex
	 *     XmuCoreIndex returns XmuCoreIndex
	 *
	 * Constraint:
	 *     (parts+=IndexPart parts+=IndexPart* body=XmuCoreStatement)
	 */
	protected void sequence_XmuCoreIndex(ISerializationContext context, XmuCoreIndex semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreMatchSource
	 *     XmuCoreCompositionChildStatement returns XmuCoreMatchSource
	 *     XmuCoreMatchSource returns XmuCoreMatchSource
	 *
	 * Constraint:
	 *     (sourceType=ContextTypeRef pattern=Pattern body=XmuCoreStatement)
	 */
	protected void sequence_XmuCoreMatchSource(ISerializationContext context, XmuCoreMatchSource semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_SOURCE__SOURCE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_SOURCE__SOURCE_TYPE));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_SOURCE__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_SOURCE__PATTERN));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_SOURCE__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_SOURCE__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXmuCoreMatchSourceAccess().getSourceTypeContextTypeRefParserRuleCall_2_0(), semanticObject.getSourceType());
		feeder.accept(grammarAccess.getXmuCoreMatchSourceAccess().getPatternPatternParserRuleCall_4_0(), semanticObject.getPattern());
		feeder.accept(grammarAccess.getXmuCoreMatchSourceAccess().getBodyXmuCoreStatementParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreMatchView
	 *     XmuCoreCompositionChildStatement returns XmuCoreMatchView
	 *     XmuCoreMatchView returns XmuCoreMatchView
	 *
	 * Constraint:
	 *     (viewType=ContextTypeRef pattern=Pattern body=XmuCoreStatement)
	 */
	protected void sequence_XmuCoreMatchView(ISerializationContext context, XmuCoreMatchView semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_VIEW__VIEW_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_VIEW__VIEW_TYPE));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_VIEW__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_VIEW__PATTERN));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_VIEW__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_MATCH_VIEW__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXmuCoreMatchViewAccess().getViewTypeContextTypeRefParserRuleCall_2_0(), semanticObject.getViewType());
		feeder.accept(grammarAccess.getXmuCoreMatchViewAccess().getPatternPatternParserRuleCall_4_0(), semanticObject.getPattern());
		feeder.accept(grammarAccess.getXmuCoreMatchViewAccess().getBodyXmuCoreStatementParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreParallelComposition
	 *     XmuCoreParallelComposition returns XmuCoreParallelComposition
	 *
	 * Constraint:
	 *     (sourceType=ContextTypeRef viewType=ContextTypeRef bodies+=XmuCoreCompositionChildStatement bodies+=XmuCoreCompositionChildStatement+)
	 */
	protected void sequence_XmuCoreParallelComposition(ISerializationContext context, XmuCoreParallelComposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreSwitchAdaption returns XmuCoreSwitchAdaption
	 *
	 * Constraint:
	 *     (condition=ContextAwareCondition action=ContextAwareUnidirectionalAction)
	 */
	protected void sequence_XmuCoreSwitchAdaption(ISerializationContext context, XmuCoreSwitchAdaption semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_SWITCH_ADAPTION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_SWITCH_ADAPTION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_SWITCH_ADAPTION__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_SWITCH_ADAPTION__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXmuCoreSwitchAdaptionAccess().getConditionContextAwareConditionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getXmuCoreSwitchAdaptionAccess().getActionContextAwareUnidirectionalActionParserRuleCall_3_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreSwitchBranch returns XmuCoreSwitchBranch
	 *
	 * Constraint:
	 *     (condition=ContextAwareCondition action=XmuCoreStatement)
	 */
	protected void sequence_XmuCoreSwitchBranch(ISerializationContext context, XmuCoreSwitchBranch semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_SWITCH_BRANCH__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_SWITCH_BRANCH__CONDITION));
			if (transientValues.isValueTransient(semanticObject, BXCorePackage.Literals.XMU_CORE_SWITCH_BRANCH__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BXCorePackage.Literals.XMU_CORE_SWITCH_BRANCH__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getXmuCoreSwitchBranchAccess().getConditionContextAwareConditionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getXmuCoreSwitchBranchAccess().getActionXmuCoreStatementParserRuleCall_3_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XmuCoreStatement returns XmuCoreSwitch
	 *     XmuCoreCompositionChildStatement returns XmuCoreSwitch
	 *     XmuCoreSwitch returns XmuCoreSwitch
	 *
	 * Constraint:
	 *     (sourceType=ContextTypeRef viewType=ContextTypeRef branches+=XmuCoreSwitchBranch+ adaptions+=XmuCoreSwitchAdaption*)
	 */
	protected void sequence_XmuCoreSwitch(ISerializationContext context, XmuCoreSwitch semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
