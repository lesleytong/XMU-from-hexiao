/*
 * generated by Xtext 2.14.0
 */
package edu.ustb.sei.mde.bxcore.dsl.validation

import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXCorePackage
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXProgram
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeLiteral
import edu.ustb.sei.mde.bxcore.dsl.infer.InferManager
import edu.ustb.sei.mde.bxcore.dsl.infer.TypeInferenceException
import edu.ustb.sei.mde.bxcore.dsl.structure.TupleType
import edu.ustb.sei.mde.structure.Tuple2
import java.util.HashMap
import java.util.List
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class BXCoreValidator extends AbstractBXCoreValidator {

	@Check
	def checkBXProgram(BXProgram program) {
		println("check");
		
		try {
			InferManager.getInferredTypeModel(program.eResource);
		} catch (Exception e) {
			if(e instanceof TypeInferenceException) {
				if(e.reason!==program) {
					if(e.reason.eContainingFeature.isMany) {
						val list = e.reason.eContainer.eGet(e.reason.eContainingFeature) as List<EObject>;
						error("type inference failed", e.reason.eContainer, e.reason.eContainingFeature, list.indexOf(e.reason));
					} else 
						error("type inference failed", e.reason.eContainer, e.reason.eContainingFeature);				
				}
				else error("type inference failed", program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
			} else error("type inference failed", program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
			
		}
	}
	
	protected def groupTypeLiterals(BXProgram program) {
		val literals = program.eAllContents.filter[e|e instanceof TypeLiteral].map[return (it as TypeLiteral)->TupleType.make(it as TypeLiteral)].toList;
		val groups = literals.groupBy[it.value];
		val result = new HashMap;
		
		groups.forEach[k,v,id|
			val pair = Tuple2.make(k,id);
			v.forEach[p|result.put(p.key, pair);];
		];
		
		return result;
	}
	
}
