/**
 * generated by Xtext 2.14.0
 */
package edu.ustb.sei.mde.bxcore.dsl.validation;

import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXCorePackage;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXProgram;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeLiteral;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreStatement;
import edu.ustb.sei.mde.bxcore.dsl.infer.SourceTypeModel;
import edu.ustb.sei.mde.bxcore.dsl.infer.UnsolvedTupleType;
import edu.ustb.sei.mde.bxcore.dsl.structure.TupleType;
import edu.ustb.sei.mde.bxcore.dsl.validation.AbstractBXCoreValidator;
import edu.ustb.sei.mde.structure.Tuple2;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.ListExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure3;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BXCoreValidator extends AbstractBXCoreValidator {
  @Check
  public void checkBXProgram(final BXProgram program) {
    final Function1<EObject, Boolean> _function = (EObject it) -> {
      return Boolean.valueOf((it instanceof XmuCoreStatement));
    };
    final Function1<EObject, XmuCoreStatement> _function_1 = (EObject it) -> {
      return ((XmuCoreStatement) it);
    };
    final List<Pair<Integer, XmuCoreStatement>> statements = IteratorExtensions.<Pair<Integer, XmuCoreStatement>>toList(IteratorExtensions.<XmuCoreStatement>indexed(IteratorExtensions.<EObject, XmuCoreStatement>map(IteratorExtensions.<EObject>filter(program.eAllContents(), _function), _function_1)));
    final HashMap<TypeLiteral, Tuple2<TupleType, Integer>> typeLiteralMap = this.groupTypeLiterals(program);
    try {
      final SourceTypeModel sourceTypeInfer = new SourceTypeModel(program, typeLiteralMap);
      sourceTypeInfer.solveNames();
      InputOutput.<String>println("name solved!");
      sourceTypeInfer.solveTypes();
      InputOutput.<String>println("type solved!");
      final Consumer<Pair<Integer, XmuCoreStatement>> _function_2 = (Pair<Integer, XmuCoreStatement> s) -> {
        final TupleType v = sourceTypeInfer.unsolvedTupleTypeMap.get(s.getValue());
        Integer _key = s.getKey();
        String _plus = ("key" + _key);
        String _plus_1 = (_plus + "=>");
        final Function1<Tuple2<String, Object>, String> _function_3 = (Tuple2<String, Object> it) -> {
          String _name = ((ENamedElement) it.second).getName();
          return ((it.first + ":") + _name);
        };
        List<String> _list = IterableExtensions.<String>toList(ListExtensions.<Tuple2<String, Object>, String>map(((UnsolvedTupleType) v).tuples, _function_3));
        String _plus_2 = (_plus_1 + _list);
        InputOutput.<String>println(_plus_2);
      };
      statements.forEach(_function_2);
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        this.error("type inference failed", program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  protected HashMap<TypeLiteral, Tuple2<TupleType, Integer>> groupTypeLiterals(final BXProgram program) {
    final Function1<EObject, Boolean> _function = (EObject e) -> {
      return Boolean.valueOf((e instanceof TypeLiteral));
    };
    final Function1<EObject, Pair<TypeLiteral, TupleType>> _function_1 = (EObject it) -> {
      TupleType _make = TupleType.make(((TypeLiteral) it));
      return Pair.<TypeLiteral, TupleType>of(((TypeLiteral) it), _make);
    };
    final List<Pair<TypeLiteral, TupleType>> literals = IteratorExtensions.<Pair<TypeLiteral, TupleType>>toList(IteratorExtensions.<EObject, Pair<TypeLiteral, TupleType>>map(IteratorExtensions.<EObject>filter(program.eAllContents(), _function), _function_1));
    final Function1<Pair<TypeLiteral, TupleType>, TupleType> _function_2 = (Pair<TypeLiteral, TupleType> it) -> {
      return it.getValue();
    };
    final Map<TupleType, List<Pair<TypeLiteral, TupleType>>> groups = IterableExtensions.<TupleType, Pair<TypeLiteral, TupleType>>groupBy(literals, _function_2);
    final HashMap<TypeLiteral, Tuple2<TupleType, Integer>> result = new HashMap<TypeLiteral, Tuple2<TupleType, Integer>>();
    final Procedure3<TupleType, List<Pair<TypeLiteral, TupleType>>, Integer> _function_3 = (TupleType k, List<Pair<TypeLiteral, TupleType>> v, Integer id) -> {
      final Tuple2<TupleType, Integer> pair = Tuple2.<TupleType, Integer>make(k, id);
      final Consumer<Pair<TypeLiteral, TupleType>> _function_4 = (Pair<TypeLiteral, TupleType> p) -> {
        result.put(p.getKey(), pair);
      };
      v.forEach(_function_4);
    };
    MapExtensions.<TupleType, List<Pair<TypeLiteral, TupleType>>>forEach(groups, _function_3);
    return result;
  }
}
