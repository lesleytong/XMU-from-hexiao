/**
 * generated by Xtext 2.14.0
 */
package edu.ustb.sei.mde.bxcore.dsl.validation;

import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXCorePackage;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXProgram;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeLiteral;
import edu.ustb.sei.mde.bxcore.dsl.infer.InferData;
import edu.ustb.sei.mde.bxcore.dsl.infer.InferManager;
import edu.ustb.sei.mde.bxcore.dsl.infer.TypeInferenceException;
import edu.ustb.sei.mde.bxcore.dsl.structure.TupleType;
import edu.ustb.sei.mde.bxcore.dsl.validation.AbstractBXCoreValidator;
import edu.ustb.sei.mde.structure.Tuple2;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.InputOutput;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure3;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BXCoreValidator extends AbstractBXCoreValidator {
  @Check
  public InferData checkBXProgram(final BXProgram program) {
    InferData _xblockexpression = null;
    {
      InputOutput.<String>println("check");
      InferData _xtrycatchfinallyexpression = null;
      try {
        _xtrycatchfinallyexpression = InferManager.getInferredTypeModel(program.eResource());
      } catch (final Throwable _t) {
        if (_t instanceof Exception) {
          final Exception e = (Exception)_t;
          if ((e instanceof TypeInferenceException)) {
            EObject _reason = ((TypeInferenceException)e).getReason();
            boolean _tripleNotEquals = (_reason != program);
            if (_tripleNotEquals) {
              boolean _isMany = ((TypeInferenceException)e).getReason().eContainingFeature().isMany();
              if (_isMany) {
                Object _eGet = ((TypeInferenceException)e).getReason().eContainer().eGet(((TypeInferenceException)e).getReason().eContainingFeature());
                final List<EObject> list = ((List<EObject>) _eGet);
                this.error("type inference failed", ((TypeInferenceException)e).getReason().eContainer(), ((TypeInferenceException)e).getReason().eContainingFeature(), list.indexOf(((TypeInferenceException)e).getReason()));
              } else {
                this.error("type inference failed", ((TypeInferenceException)e).getReason().eContainer(), ((TypeInferenceException)e).getReason().eContainingFeature());
              }
            } else {
              this.error("type inference failed", program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
            }
          } else {
            this.error("type inference failed", program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
          }
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      _xblockexpression = _xtrycatchfinallyexpression;
    }
    return _xblockexpression;
  }
  
  protected HashMap<TypeLiteral, Tuple2<TupleType, Integer>> groupTypeLiterals(final BXProgram program) {
    final Function1<EObject, Boolean> _function = (EObject e) -> {
      return Boolean.valueOf((e instanceof TypeLiteral));
    };
    final Function1<EObject, Pair<TypeLiteral, TupleType>> _function_1 = (EObject it) -> {
      TupleType _make = TupleType.make(((TypeLiteral) it));
      return Pair.<TypeLiteral, TupleType>of(((TypeLiteral) it), _make);
    };
    final List<Pair<TypeLiteral, TupleType>> literals = IteratorExtensions.<Pair<TypeLiteral, TupleType>>toList(IteratorExtensions.<EObject, Pair<TypeLiteral, TupleType>>map(IteratorExtensions.<EObject>filter(program.eAllContents(), _function), _function_1));
    final Function1<Pair<TypeLiteral, TupleType>, TupleType> _function_2 = (Pair<TypeLiteral, TupleType> it) -> {
      return it.getValue();
    };
    final Map<TupleType, List<Pair<TypeLiteral, TupleType>>> groups = IterableExtensions.<TupleType, Pair<TypeLiteral, TupleType>>groupBy(literals, _function_2);
    final HashMap<TypeLiteral, Tuple2<TupleType, Integer>> result = new HashMap<TypeLiteral, Tuple2<TupleType, Integer>>();
    final Procedure3<TupleType, List<Pair<TypeLiteral, TupleType>>, Integer> _function_3 = (TupleType k, List<Pair<TypeLiteral, TupleType>> v, Integer id) -> {
      final Tuple2<TupleType, Integer> pair = Tuple2.<TupleType, Integer>make(k, id);
      final Consumer<Pair<TypeLiteral, TupleType>> _function_4 = (Pair<TypeLiteral, TupleType> p) -> {
        result.put(p.getKey(), pair);
      };
      v.forEach(_function_4);
    };
    MapExtensions.<TupleType, List<Pair<TypeLiteral, TupleType>>>forEach(groups, _function_3);
    return result;
  }
}
