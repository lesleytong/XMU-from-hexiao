/**
 * generated by Xtext 2.14.0
 */
package edu.ustb.sei.mde.bxcore.dsl.validation;

import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXCorePackage;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXFunctionDefinition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXProgram;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.Conversion;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.ModificationExpressionBlock;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.Pattern;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternDefinitionReference;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.PatternTypeLiteral;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeLiteral;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeVar;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreContextSource;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreDependencyView;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreDeriveSource;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreExpandSource;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreExpandView;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreFork;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreFunctionCall;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreGraphReplace;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreIndex;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreStatement;
import edu.ustb.sei.mde.bxcore.dsl.infer.InferData;
import edu.ustb.sei.mde.bxcore.dsl.infer.InferManager;
import edu.ustb.sei.mde.bxcore.dsl.infer.TypeInferenceException;
import edu.ustb.sei.mde.bxcore.dsl.structure.TupleType;
import edu.ustb.sei.mde.bxcore.dsl.validation.AbstractBXCoreValidator;
import edu.ustb.sei.mde.structure.Tuple2;
import edu.ustb.sei.mde.structure.Tuple3;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.ecore.ENamedElement;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XExpression;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure3;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BXCoreValidator extends AbstractBXCoreValidator {
  @Check
  public InferData checkBXProgram(final BXProgram program) {
    InferData _xtrycatchfinallyexpression = null;
    try {
      _xtrycatchfinallyexpression = InferManager.getInferredTypeModel(program.eResource());
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        if ((e instanceof TypeInferenceException)) {
          EObject _reason = ((TypeInferenceException)e).getReason();
          boolean _tripleNotEquals = (_reason != program);
          if (_tripleNotEquals) {
            this.error(((TypeInferenceException)e).getMessage(), ((TypeInferenceException)e).getReason());
          } else {
            this.error(((TypeInferenceException)e).getMessage(), program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
          }
        } else {
          this.error(e.getMessage(), program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
        }
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    return _xtrycatchfinallyexpression;
  }
  
  @Check
  public void checkXmuCoreStatement(final XmuCoreStatement stat) {
    try {
      final InferData data = InferManager.safeGetInferredTypeModel(stat.eResource());
      if (((stat.getTypeIndicator() != null) && (data != null))) {
        final TupleType inferredSource = data.getSourceInfer().getType(stat);
        final TupleType definedSource = data.getSourceInfer().getType(stat.getTypeIndicator().getSourceType());
        boolean _compare = inferredSource.compare(definedSource);
        boolean _tripleEquals = (Boolean.valueOf(_compare) == Boolean.valueOf(false));
        if (_tripleEquals) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The defined source type is different from the inferred type");
          _builder.newLine();
          _builder.append("\t\t\t\t");
          _builder.append("The inferred type is ");
          CharSequence _text = this.text(inferredSource);
          _builder.append(_text, "\t\t\t\t");
          this.warning(_builder.toString(), stat);
        }
        final TupleType inferredView = data.getViewInfer().getType(stat);
        final TupleType definedView = data.getViewInfer().getType(stat.getTypeIndicator().getViewType());
        boolean _compare_1 = inferredView.compare(definedView);
        boolean _tripleEquals_1 = (Boolean.valueOf(_compare_1) == Boolean.valueOf(false));
        if (_tripleEquals_1) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("The defined view type is different from the inferred type");
          _builder_1.newLine();
          _builder_1.append("\t\t\t\t");
          _builder_1.append("The inferred type is ");
          CharSequence _text_1 = this.text(inferredSource);
          _builder_1.append(_text_1, "\t\t\t\t");
          this.warning(_builder_1.toString(), stat);
        }
      }
      if ((data != null)) {
        this.checkVarMappings(stat, data);
      }
      if ((stat instanceof XmuCoreContextSource)) {
        int _size = ((XmuCoreContextSource)stat).getMappingSource().getElements().size();
        int _size_1 = ((XmuCoreContextSource)stat).getMappingView().getElements().size();
        boolean _tripleNotEquals = (_size != _size_1);
        if (_tripleNotEquals) {
          StringConcatenation _builder_2 = new StringConcatenation();
          _builder_2.append("The count of source vars should be equal to the count of the view vars");
          this.error(_builder_2.toString(), stat);
        }
      } else {
        if ((stat instanceof XmuCoreDeriveSource)) {
          int _size_2 = ((XmuCoreDeriveSource)stat).getDerivedType().getElements().size();
          int _size_3 = ((XmuCoreDeriveSource)stat).getDerivationFunctions().size();
          boolean _tripleNotEquals_1 = (_size_2 != _size_3);
          if (_tripleNotEquals_1) {
            StringConcatenation _builder_3 = new StringConcatenation();
            _builder_3.append("The count of source vars should be equal to the count of the derivation functions");
            this.error(_builder_3.toString(), stat);
          }
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public CharSequence text(final TupleType type) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("(");
    {
      boolean _hasElements = false;
      for(final Tuple3<String, Object, Boolean> t : type.tuples) {
        if (!_hasElements) {
          _hasElements = true;
        } else {
          _builder.appendImmediate(",", "");
        }
        _builder.append(t.first);
        _builder.append(":");
        String _text = this.text(t.second);
        _builder.append(_text);
        {
          if ((t.third).booleanValue()) {
            _builder.append("[]");
          }
        }
      }
    }
    _builder.append(")");
    return _builder;
  }
  
  public String text(final Object object) {
    String _xifexpression = null;
    if ((object instanceof ENamedElement)) {
      _xifexpression = ((ENamedElement)object).getName();
    } else {
      _xifexpression = object.toString();
    }
    return _xifexpression;
  }
  
  public void checkVarMappings(final XmuCoreStatement statement, final InferData data) {
    if ((statement instanceof XmuCoreExpandSource)) {
    } else {
      if ((statement instanceof XmuCoreExpandView)) {
      } else {
        if ((statement instanceof XmuCoreFork)) {
        } else {
          if ((statement instanceof XmuCoreGraphReplace)) {
            final TupleType srcType = data.getSourceInfer().getType(statement);
            final TupleType viwType = data.getViewInfer().getType(statement);
            final Consumer<Conversion> _function = (Conversion c) -> {
              final Function1<String, Boolean> _function_1 = (String s) -> {
                final Function1<Tuple3<String, Object, Boolean>, Boolean> _function_2 = (Tuple3<String, Object, Boolean> t) -> {
                  return Boolean.valueOf(t.first.equals(s));
                };
                boolean _exists = IterableExtensions.<Tuple3<String, Object, Boolean>>exists(srcType.tuples, _function_2);
                return Boolean.valueOf((!_exists));
              };
              boolean _exists = IterableExtensions.<String>exists(c.getSource(), _function_1);
              if (_exists) {
                this.error("undefined source variable", c);
              }
              final Function1<String, Boolean> _function_2 = (String s) -> {
                final Function1<Tuple3<String, Object, Boolean>, Boolean> _function_3 = (Tuple3<String, Object, Boolean> t) -> {
                  return Boolean.valueOf(t.first.equals(s));
                };
                boolean _exists_1 = IterableExtensions.<Tuple3<String, Object, Boolean>>exists(viwType.tuples, _function_3);
                return Boolean.valueOf((!_exists_1));
              };
              boolean _exists_1 = IterableExtensions.<String>exists(c.getView(), _function_2);
              if (_exists_1) {
                this.error("undefined view variable", c);
              }
            };
            ((XmuCoreGraphReplace)statement).getConversions().forEach(_function);
          } else {
            if ((statement instanceof XmuCoreFunctionCall)) {
            } else {
              if ((statement instanceof XmuCoreIndex)) {
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkBXFunction(final BXFunctionDefinition func) {
    try {
      final InferData data = InferManager.safeGetInferredTypeModel(func.eResource());
      if (((func.getTypeIndicator() != null) && (data != null))) {
        final TupleType inferredSource = data.getSourceInfer().getType(func);
        final TupleType definedSource = data.getSourceInfer().getType(func.getTypeIndicator().getSourceType());
        boolean _compare = inferredSource.compare(definedSource);
        boolean _tripleEquals = (Boolean.valueOf(_compare) == Boolean.valueOf(false));
        if (_tripleEquals) {
          StringConcatenation _builder = new StringConcatenation();
          _builder.append("The defined source type is different from the inferred type");
          _builder.newLine();
          _builder.append("\t\t\t\t");
          _builder.append("The inferred type is ");
          CharSequence _text = this.text(inferredSource);
          _builder.append(_text, "\t\t\t\t");
          this.warning(_builder.toString(), func);
        }
        final TupleType inferredView = data.getViewInfer().getType(func);
        final TupleType definedView = data.getViewInfer().getType(func.getTypeIndicator().getViewType());
        boolean _compare_1 = inferredView.compare(definedView);
        boolean _tripleEquals_1 = (Boolean.valueOf(_compare_1) == Boolean.valueOf(false));
        if (_tripleEquals_1) {
          StringConcatenation _builder_1 = new StringConcatenation();
          _builder_1.append("The defined view type is different from the inferred type");
          _builder_1.newLine();
          _builder_1.append("\t\t\t\t");
          _builder_1.append("The inferred type is ");
          CharSequence _text_1 = this.text(inferredSource);
          _builder_1.append(_text_1, "\t\t\t\t");
          this.warning(_builder_1.toString(), func);
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Check
  public void checkPattern(final Pattern e) {
    PatternTypeLiteral _xifexpression = null;
    if ((e instanceof PatternTypeLiteral)) {
      _xifexpression = ((PatternTypeLiteral) e);
    } else {
      TypeLiteral _literal = ((PatternDefinitionReference) e).getPattern().getLiteral();
      _xifexpression = ((PatternTypeLiteral) _literal);
    }
    final PatternTypeLiteral pat = _xifexpression;
    boolean _isEmpty = pat.getAdditional().isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      final boolean isSource = this.isSource(e.eContainingFeature());
      final List<TypeVar> initializedVars = this.getVarsWithInitializer(e, isSource);
      if ((!isSource)) {
        final Procedure1<EObject> _function = (EObject c) -> {
          if ((c instanceof XmuCoreDependencyView)) {
            initializedVars.addAll(((XmuCoreDependencyView)c).getDependentType().getElements());
          }
        };
        IteratorExtensions.<EObject>forEach(e.eContainer().eAllContents(), _function);
      }
      final Function1<TypeVar, Boolean> _function_1 = (TypeVar f) -> {
        final Function1<TypeVar, Boolean> _function_2 = (TypeVar v) -> {
          return Boolean.valueOf(v.getName().equals(f.getName()));
        };
        TypeVar _findFirst = IterableExtensions.<TypeVar>findFirst(initializedVars, _function_2);
        Pair<TypeVar, TypeVar> _mappedTo = Pair.<TypeVar, TypeVar>of(f, _findFirst);
        return Boolean.valueOf((_mappedTo == null));
      };
      final TypeVar uninitialized = IterableExtensions.<TypeVar>findFirst(pat.getAdditional(), _function_1);
      if ((uninitialized != null)) {
        this.warning("The additional variable may be uninitialized", uninitialized);
      }
    }
  }
  
  public boolean isSource(final EStructuralFeature contain) {
    boolean _xifexpression = false;
    if ((((((contain == BXCorePackage.Literals.XMU_CORE_ALIGN__SOURCE_PATTERN) || (contain == BXCorePackage.Literals.XMU_CORE_MATCH_SOURCE__PATTERN)) || (contain == BXCorePackage.Literals.XMU_CORE_EXPAND_SOURCE__PATTERN)) || (contain == BXCorePackage.Literals.XMU_CORE_FOR_EACH_MATCH_SOURCE__PATTERN)) || (contain == BXCorePackage.Literals.XMU_CORE_GRAPH_REPLACE__SOURCE))) {
      _xifexpression = true;
    } else {
      _xifexpression = false;
    }
    return _xifexpression;
  }
  
  public List<TypeVar> getVarsWithInitializer(final EObject e, final boolean isSource) {
    if (((e == null) || (e instanceof BXFunctionDefinition))) {
      return new ArrayList<TypeVar>();
    }
    final List<TypeVar> res = this.getVarsWithInitializer(e.eContainer(), isSource);
    if (((e instanceof XmuCoreContextSource) && (Boolean.valueOf(isSource) == Boolean.valueOf(false)))) {
      res.addAll(((XmuCoreContextSource) e).getMappingView().getElements());
    } else {
      if (((e instanceof XmuCoreDeriveSource) && isSource)) {
        res.addAll(((XmuCoreDeriveSource) e).getDerivedType().getElements());
      }
    }
    return res;
  }
  
  public void warning(final String message, final EObject obj) {
    boolean _isMany = obj.eContainingFeature().isMany();
    if (_isMany) {
      Object _eGet = obj.eContainer().eGet(obj.eContainingFeature());
      final List<EObject> list = ((List<EObject>) _eGet);
      this.warning(message, obj.eContainer(), obj.eContainingFeature(), list.indexOf(obj));
    } else {
      this.warning(message, obj.eContainer(), obj.eContainingFeature());
    }
  }
  
  public void error(final String message, final EObject obj) {
    boolean _isMany = obj.eContainingFeature().isMany();
    if (_isMany) {
      Object _eGet = obj.eContainer().eGet(obj.eContainingFeature());
      final List<EObject> list = ((List<EObject>) _eGet);
      this.error(message, obj.eContainer(), obj.eContainingFeature(), list.indexOf(obj));
    } else {
      this.error(message, obj.eContainer(), obj.eContainingFeature());
    }
  }
  
  protected HashMap<TypeLiteral, Tuple2<TupleType, Integer>> groupTypeLiterals(final BXProgram program) {
    final Function1<EObject, Boolean> _function = (EObject e) -> {
      return Boolean.valueOf((e instanceof TypeLiteral));
    };
    final Function1<EObject, Pair<TypeLiteral, TupleType>> _function_1 = (EObject it) -> {
      TupleType _make = TupleType.make(((TypeLiteral) it));
      return Pair.<TypeLiteral, TupleType>of(((TypeLiteral) it), _make);
    };
    final List<Pair<TypeLiteral, TupleType>> literals = IteratorExtensions.<Pair<TypeLiteral, TupleType>>toList(IteratorExtensions.<EObject, Pair<TypeLiteral, TupleType>>map(IteratorExtensions.<EObject>filter(program.eAllContents(), _function), _function_1));
    final Function1<Pair<TypeLiteral, TupleType>, TupleType> _function_2 = (Pair<TypeLiteral, TupleType> it) -> {
      return it.getValue();
    };
    final Map<TupleType, List<Pair<TypeLiteral, TupleType>>> groups = IterableExtensions.<TupleType, Pair<TypeLiteral, TupleType>>groupBy(literals, _function_2);
    final HashMap<TypeLiteral, Tuple2<TupleType, Integer>> result = new HashMap<TypeLiteral, Tuple2<TupleType, Integer>>();
    final Procedure3<TupleType, List<Pair<TypeLiteral, TupleType>>, Integer> _function_3 = (TupleType k, List<Pair<TypeLiteral, TupleType>> v, Integer id) -> {
      final Tuple2<TupleType, Integer> pair = Tuple2.<TupleType, Integer>make(k, id);
      final Consumer<Pair<TypeLiteral, TupleType>> _function_4 = (Pair<TypeLiteral, TupleType> p) -> {
        result.put(p.getKey(), pair);
      };
      v.forEach(_function_4);
    };
    MapExtensions.<TupleType, List<Pair<TypeLiteral, TupleType>>>forEach(groups, _function_3);
    return result;
  }
  
  @Check
  public void checkContextAwareUnidirectionalAction(final XBlockExpression block) {
    final Function1<XExpression, Boolean> _function = (XExpression it) -> {
      return Boolean.valueOf((it instanceof ModificationExpressionBlock));
    };
    final Procedure2<XExpression, Integer> _function_1 = (XExpression b, Integer id) -> {
      if (((id).intValue() > 0)) {
        this.error("More than one modification block in the context", b);
      }
    };
    IterableExtensions.<XExpression>forEach(IterableExtensions.<XExpression>filter(block.getExpressions(), _function), _function_1);
  }
}
