/**
 * generated by Xtext 2.14.0
 */
package edu.ustb.sei.mde.bxcore.dsl.validation;

import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXCorePackage;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXFunctionDefinition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXProgram;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeLiteral;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreStatement;
import edu.ustb.sei.mde.bxcore.dsl.infer.InferData;
import edu.ustb.sei.mde.bxcore.dsl.infer.InferManager;
import edu.ustb.sei.mde.bxcore.dsl.infer.TypeInferenceException;
import edu.ustb.sei.mde.bxcore.dsl.structure.TupleType;
import edu.ustb.sei.mde.bxcore.dsl.validation.AbstractBXCoreValidator;
import edu.ustb.sei.mde.structure.Tuple2;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure3;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BXCoreValidator extends AbstractBXCoreValidator {
  @Check
  public InferData checkBXProgram(final BXProgram program) {
    InferData _xtrycatchfinallyexpression = null;
    try {
      _xtrycatchfinallyexpression = InferManager.getInferredTypeModel(program.eResource());
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        if ((e instanceof TypeInferenceException)) {
          EObject _reason = ((TypeInferenceException)e).getReason();
          boolean _tripleNotEquals = (_reason != program);
          if (_tripleNotEquals) {
            this.error("type inference failed", ((TypeInferenceException)e).getReason());
          } else {
            this.error("type inference failed", program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
          }
        } else {
          this.error("type inference failed", program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
        }
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    return _xtrycatchfinallyexpression;
  }
  
  @Check
  public void checkXmuCoreStatement(final XmuCoreStatement stat) {
    try {
      final InferData data = InferManager.safeGetInferredTypeModel(stat.eResource());
      if (((stat.getTypeIndicator() != null) && (data != null))) {
        final TupleType inferredSource = data.getSourceInfer().getType(stat);
        final TupleType definedSource = data.getSourceInfer().getType(stat.getTypeIndicator().getSourceType());
        boolean _compare = inferredSource.compare(definedSource);
        boolean _tripleEquals = (Boolean.valueOf(_compare) == Boolean.valueOf(false));
        if (_tripleEquals) {
          this.warning("The defined source type is different from the inferred type", stat);
        }
        final TupleType inferredView = data.getViewInfer().getType(stat);
        final TupleType definedView = data.getViewInfer().getType(stat.getTypeIndicator().getViewType());
        boolean _compare_1 = inferredView.compare(definedView);
        boolean _tripleEquals_1 = (Boolean.valueOf(_compare_1) == Boolean.valueOf(false));
        if (_tripleEquals_1) {
          this.warning("The defined view type is different from the inferred type", stat);
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Check
  public void checkBXFunction(final BXFunctionDefinition func) {
    try {
      final InferData data = InferManager.safeGetInferredTypeModel(func.eResource());
      if (((func.getTypeIndicator() != null) && (data != null))) {
        final TupleType inferredSource = data.getSourceInfer().getType(func);
        final TupleType definedSource = data.getSourceInfer().getType(func.getTypeIndicator().getSourceType());
        boolean _compare = inferredSource.compare(definedSource);
        boolean _tripleEquals = (Boolean.valueOf(_compare) == Boolean.valueOf(false));
        if (_tripleEquals) {
          this.warning("The defined source type is different from the inferred type", func);
        }
        final TupleType inferredView = data.getViewInfer().getType(func);
        final TupleType definedView = data.getViewInfer().getType(func.getTypeIndicator().getViewType());
        boolean _compare_1 = inferredView.compare(definedView);
        boolean _tripleEquals_1 = (Boolean.valueOf(_compare_1) == Boolean.valueOf(false));
        if (_tripleEquals_1) {
          this.warning("The defined view type is different from the inferred type", func);
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void warning(final String message, final EObject obj) {
    boolean _isMany = obj.eContainingFeature().isMany();
    if (_isMany) {
      Object _eGet = obj.eContainer().eGet(obj.eContainingFeature());
      final List<EObject> list = ((List<EObject>) _eGet);
      this.warning(message, obj.eContainer(), obj.eContainingFeature(), list.indexOf(obj));
    } else {
      this.warning(message, obj.eContainer(), obj.eContainingFeature());
    }
  }
  
  public void error(final String message, final EObject obj) {
    boolean _isMany = obj.eContainingFeature().isMany();
    if (_isMany) {
      Object _eGet = obj.eContainer().eGet(obj.eContainingFeature());
      final List<EObject> list = ((List<EObject>) _eGet);
      this.error(message, obj.eContainer(), obj.eContainingFeature(), list.indexOf(obj));
    } else {
      this.error(message, obj.eContainer(), obj.eContainingFeature());
    }
  }
  
  protected HashMap<TypeLiteral, Tuple2<TupleType, Integer>> groupTypeLiterals(final BXProgram program) {
    final Function1<EObject, Boolean> _function = (EObject e) -> {
      return Boolean.valueOf((e instanceof TypeLiteral));
    };
    final Function1<EObject, Pair<TypeLiteral, TupleType>> _function_1 = (EObject it) -> {
      TupleType _make = TupleType.make(((TypeLiteral) it));
      return Pair.<TypeLiteral, TupleType>of(((TypeLiteral) it), _make);
    };
    final List<Pair<TypeLiteral, TupleType>> literals = IteratorExtensions.<Pair<TypeLiteral, TupleType>>toList(IteratorExtensions.<EObject, Pair<TypeLiteral, TupleType>>map(IteratorExtensions.<EObject>filter(program.eAllContents(), _function), _function_1));
    final Function1<Pair<TypeLiteral, TupleType>, TupleType> _function_2 = (Pair<TypeLiteral, TupleType> it) -> {
      return it.getValue();
    };
    final Map<TupleType, List<Pair<TypeLiteral, TupleType>>> groups = IterableExtensions.<TupleType, Pair<TypeLiteral, TupleType>>groupBy(literals, _function_2);
    final HashMap<TypeLiteral, Tuple2<TupleType, Integer>> result = new HashMap<TypeLiteral, Tuple2<TupleType, Integer>>();
    final Procedure3<TupleType, List<Pair<TypeLiteral, TupleType>>, Integer> _function_3 = (TupleType k, List<Pair<TypeLiteral, TupleType>> v, Integer id) -> {
      final Tuple2<TupleType, Integer> pair = Tuple2.<TupleType, Integer>make(k, id);
      final Consumer<Pair<TypeLiteral, TupleType>> _function_4 = (Pair<TypeLiteral, TupleType> p) -> {
        result.put(p.getKey(), pair);
      };
      v.forEach(_function_4);
    };
    MapExtensions.<TupleType, List<Pair<TypeLiteral, TupleType>>>forEach(groups, _function_3);
    return result;
  }
}
