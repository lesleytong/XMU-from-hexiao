/**
 * generated by Xtext 2.14.0
 */
package edu.ustb.sei.mde.bxcore.dsl.validation;

import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXCorePackage;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXFunctionDefinition;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.BXProgram;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.Conversion;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.TypeLiteral;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreExpandSource;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreExpandView;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreFork;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreFunctionCall;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreGraphReplace;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreIndex;
import edu.ustb.sei.mde.bxcore.dsl.bXCore.XmuCoreStatement;
import edu.ustb.sei.mde.bxcore.dsl.infer.InferData;
import edu.ustb.sei.mde.bxcore.dsl.infer.InferManager;
import edu.ustb.sei.mde.bxcore.dsl.infer.TypeInferenceException;
import edu.ustb.sei.mde.bxcore.dsl.structure.TupleType;
import edu.ustb.sei.mde.bxcore.dsl.validation.AbstractBXCoreValidator;
import edu.ustb.sei.mde.structure.Tuple2;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Consumer;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.eclipse.xtext.xbase.lib.MapExtensions;
import org.eclipse.xtext.xbase.lib.Pair;
import org.eclipse.xtext.xbase.lib.Procedures.Procedure3;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class BXCoreValidator extends AbstractBXCoreValidator {
  @Check
  public InferData checkBXProgram(final BXProgram program) {
    InferData _xtrycatchfinallyexpression = null;
    try {
      _xtrycatchfinallyexpression = InferManager.getInferredTypeModel(program.eResource());
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        if ((e instanceof TypeInferenceException)) {
          EObject _reason = ((TypeInferenceException)e).getReason();
          boolean _tripleNotEquals = (_reason != program);
          if (_tripleNotEquals) {
            this.error(((TypeInferenceException)e).getMessage(), ((TypeInferenceException)e).getReason());
          } else {
            this.error(((TypeInferenceException)e).getMessage(), program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
          }
        } else {
          this.error(e.getMessage(), program, BXCorePackage.Literals.BX_PROGRAM__DEFINITIONS);
        }
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
    return _xtrycatchfinallyexpression;
  }
  
  @Check
  public void checkXmuCoreStatement(final XmuCoreStatement stat) {
    try {
      final InferData data = InferManager.safeGetInferredTypeModel(stat.eResource());
      if (((stat.getTypeIndicator() != null) && (data != null))) {
        final TupleType inferredSource = data.getSourceInfer().getType(stat);
        final TupleType definedSource = data.getSourceInfer().getType(stat.getTypeIndicator().getSourceType());
        boolean _compare = inferredSource.compare(definedSource);
        boolean _tripleEquals = (Boolean.valueOf(_compare) == Boolean.valueOf(false));
        if (_tripleEquals) {
          this.warning("The defined source type is different from the inferred type", stat);
        }
        final TupleType inferredView = data.getViewInfer().getType(stat);
        final TupleType definedView = data.getViewInfer().getType(stat.getTypeIndicator().getViewType());
        boolean _compare_1 = inferredView.compare(definedView);
        boolean _tripleEquals_1 = (Boolean.valueOf(_compare_1) == Boolean.valueOf(false));
        if (_tripleEquals_1) {
          this.warning("The defined view type is different from the inferred type", stat);
        }
      }
      if ((data != null)) {
        this.checkVarMappings(stat, data);
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void checkVarMappings(final XmuCoreStatement statement, final InferData data) {
    if ((statement instanceof XmuCoreExpandSource)) {
    } else {
      if ((statement instanceof XmuCoreExpandView)) {
      } else {
        if ((statement instanceof XmuCoreFork)) {
        } else {
          if ((statement instanceof XmuCoreGraphReplace)) {
            final TupleType srcType = data.getSourceInfer().getType(statement);
            final TupleType viwType = data.getViewInfer().getType(statement);
            final Consumer<Conversion> _function = (Conversion c) -> {
              final Function1<String, Boolean> _function_1 = (String s) -> {
                final Function1<Tuple2<String, Object>, Boolean> _function_2 = (Tuple2<String, Object> t) -> {
                  return Boolean.valueOf(t.first.equals(s));
                };
                boolean _exists = IterableExtensions.<Tuple2<String, Object>>exists(srcType.tuples, _function_2);
                return Boolean.valueOf((!_exists));
              };
              boolean _exists = IterableExtensions.<String>exists(c.getSource(), _function_1);
              if (_exists) {
                this.error("undefined source variable", c);
              }
              final Function1<String, Boolean> _function_2 = (String s) -> {
                final Function1<Tuple2<String, Object>, Boolean> _function_3 = (Tuple2<String, Object> t) -> {
                  return Boolean.valueOf(t.first.equals(s));
                };
                boolean _exists_1 = IterableExtensions.<Tuple2<String, Object>>exists(viwType.tuples, _function_3);
                return Boolean.valueOf((!_exists_1));
              };
              boolean _exists_1 = IterableExtensions.<String>exists(c.getView(), _function_2);
              if (_exists_1) {
                this.error("undefined source variable", c);
              }
            };
            ((XmuCoreGraphReplace)statement).getConversions().forEach(_function);
          } else {
            if ((statement instanceof XmuCoreFunctionCall)) {
            } else {
              if ((statement instanceof XmuCoreIndex)) {
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkBXFunction(final BXFunctionDefinition func) {
    try {
      final InferData data = InferManager.safeGetInferredTypeModel(func.eResource());
      if (((func.getTypeIndicator() != null) && (data != null))) {
        final TupleType inferredSource = data.getSourceInfer().getType(func);
        final TupleType definedSource = data.getSourceInfer().getType(func.getTypeIndicator().getSourceType());
        boolean _compare = inferredSource.compare(definedSource);
        boolean _tripleEquals = (Boolean.valueOf(_compare) == Boolean.valueOf(false));
        if (_tripleEquals) {
          this.warning("The defined source type is different from the inferred type", func);
        }
        final TupleType inferredView = data.getViewInfer().getType(func);
        final TupleType definedView = data.getViewInfer().getType(func.getTypeIndicator().getViewType());
        boolean _compare_1 = inferredView.compare(definedView);
        boolean _tripleEquals_1 = (Boolean.valueOf(_compare_1) == Boolean.valueOf(false));
        if (_tripleEquals_1) {
          this.warning("The defined view type is different from the inferred type", func);
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  public void warning(final String message, final EObject obj) {
    boolean _isMany = obj.eContainingFeature().isMany();
    if (_isMany) {
      Object _eGet = obj.eContainer().eGet(obj.eContainingFeature());
      final List<EObject> list = ((List<EObject>) _eGet);
      this.warning(message, obj.eContainer(), obj.eContainingFeature(), list.indexOf(obj));
    } else {
      this.warning(message, obj.eContainer(), obj.eContainingFeature());
    }
  }
  
  public void error(final String message, final EObject obj) {
    boolean _isMany = obj.eContainingFeature().isMany();
    if (_isMany) {
      Object _eGet = obj.eContainer().eGet(obj.eContainingFeature());
      final List<EObject> list = ((List<EObject>) _eGet);
      this.error(message, obj.eContainer(), obj.eContainingFeature(), list.indexOf(obj));
    } else {
      this.error(message, obj.eContainer(), obj.eContainingFeature());
    }
  }
  
  protected HashMap<TypeLiteral, Tuple2<TupleType, Integer>> groupTypeLiterals(final BXProgram program) {
    final Function1<EObject, Boolean> _function = (EObject e) -> {
      return Boolean.valueOf((e instanceof TypeLiteral));
    };
    final Function1<EObject, Pair<TypeLiteral, TupleType>> _function_1 = (EObject it) -> {
      TupleType _make = TupleType.make(((TypeLiteral) it));
      return Pair.<TypeLiteral, TupleType>of(((TypeLiteral) it), _make);
    };
    final List<Pair<TypeLiteral, TupleType>> literals = IteratorExtensions.<Pair<TypeLiteral, TupleType>>toList(IteratorExtensions.<EObject, Pair<TypeLiteral, TupleType>>map(IteratorExtensions.<EObject>filter(program.eAllContents(), _function), _function_1));
    final Function1<Pair<TypeLiteral, TupleType>, TupleType> _function_2 = (Pair<TypeLiteral, TupleType> it) -> {
      return it.getValue();
    };
    final Map<TupleType, List<Pair<TypeLiteral, TupleType>>> groups = IterableExtensions.<TupleType, Pair<TypeLiteral, TupleType>>groupBy(literals, _function_2);
    final HashMap<TypeLiteral, Tuple2<TupleType, Integer>> result = new HashMap<TypeLiteral, Tuple2<TupleType, Integer>>();
    final Procedure3<TupleType, List<Pair<TypeLiteral, TupleType>>, Integer> _function_3 = (TupleType k, List<Pair<TypeLiteral, TupleType>> v, Integer id) -> {
      final Tuple2<TupleType, Integer> pair = Tuple2.<TupleType, Integer>make(k, id);
      final Consumer<Pair<TypeLiteral, TupleType>> _function_4 = (Pair<TypeLiteral, TupleType> p) -> {
        result.put(p.getKey(), pair);
      };
      v.forEach(_function_4);
    };
    MapExtensions.<TupleType, List<Pair<TypeLiteral, TupleType>>>forEach(groups, _function_3);
    return result;
  }
}
