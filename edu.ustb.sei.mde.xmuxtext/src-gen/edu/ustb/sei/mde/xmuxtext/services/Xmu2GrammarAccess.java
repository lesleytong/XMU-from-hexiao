/*
 * generated by Xtext 2.10.0
 */
package edu.ustb.sei.mde.xmuxtext.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class Xmu2GrammarAccess extends AbstractGrammarElementFinder {
	
	public class TransformationModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.TransformationModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cTransformationModelAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cModuleKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cNameNAMETerminalRuleCall_2_0 = (RuleCall)cNameAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cImportKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cPackagesAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final CrossReference cPackagesEPackageCrossReference_3_1_0 = (CrossReference)cPackagesAssignment_3_1.eContents().get(0);
		private final RuleCall cPackagesEPackageMODEL_URITerminalRuleCall_3_1_0_1 = (RuleCall)cPackagesEPackageCrossReference_3_1_0.eContents().get(1);
		private final Assignment cEntryPointsAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cEntryPointsEntryPointParserRuleCall_4_0 = (RuleCall)cEntryPointsAssignment_4.eContents().get(0);
		private final Assignment cRulesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cRulesAbstractRuleParserRuleCall_5_0 = (RuleCall)cRulesAssignment_5.eContents().get(0);
		
		//TransformationModel xmu2::TransformationModel:
		//	{xmu2::TransformationModel}
		//	'module' name=NAME ('import' packages+=[ecore::EPackage|MODEL_URI])*
		//	entryPoints+=EntryPoint*
		//	rules+=AbstractRule*
		@Override public ParserRule getRule() { return rule; }
		
		//{xmu2::TransformationModel} 'module' name=NAME ('import' packages+=[ecore::EPackage|MODEL_URI])*
		//entryPoints+=EntryPoint* rules+=AbstractRule*
		public Group getGroup() { return cGroup; }
		
		//{xmu2::TransformationModel}
		public Action getTransformationModelAction_0() { return cTransformationModelAction_0; }
		
		//'module'
		public Keyword getModuleKeyword_1() { return cModuleKeyword_1; }
		
		//name=NAME
		public Assignment getNameAssignment_2() { return cNameAssignment_2; }
		
		//NAME
		public RuleCall getNameNAMETerminalRuleCall_2_0() { return cNameNAMETerminalRuleCall_2_0; }
		
		//('import' packages+=[ecore::EPackage|MODEL_URI])*
		public Group getGroup_3() { return cGroup_3; }
		
		//'import'
		public Keyword getImportKeyword_3_0() { return cImportKeyword_3_0; }
		
		//packages+=[ecore::EPackage|MODEL_URI]
		public Assignment getPackagesAssignment_3_1() { return cPackagesAssignment_3_1; }
		
		//[ecore::EPackage|MODEL_URI]
		public CrossReference getPackagesEPackageCrossReference_3_1_0() { return cPackagesEPackageCrossReference_3_1_0; }
		
		//MODEL_URI
		public RuleCall getPackagesEPackageMODEL_URITerminalRuleCall_3_1_0_1() { return cPackagesEPackageMODEL_URITerminalRuleCall_3_1_0_1; }
		
		//entryPoints+=EntryPoint*
		public Assignment getEntryPointsAssignment_4() { return cEntryPointsAssignment_4; }
		
		//EntryPoint
		public RuleCall getEntryPointsEntryPointParserRuleCall_4_0() { return cEntryPointsEntryPointParserRuleCall_4_0; }
		
		//rules+=AbstractRule*
		public Assignment getRulesAssignment_5() { return cRulesAssignment_5; }
		
		//AbstractRule
		public RuleCall getRulesAbstractRuleParserRuleCall_5_0() { return cRulesAbstractRuleParserRuleCall_5_0; }
	}
	public class EntryPointElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.EntryPoint");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEntryKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cRuleAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cRuleModelRuleCrossReference_1_0 = (CrossReference)cRuleAssignment_1.eContents().get(0);
		private final RuleCall cRuleModelRuleNAMETerminalRuleCall_1_0_1 = (RuleCall)cRuleModelRuleCrossReference_1_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cParametersAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cParametersEntryDataParserRuleCall_3_0 = (RuleCall)cParametersAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cCommaKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cParametersAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cParametersEntryDataParserRuleCall_4_1_0 = (RuleCall)cParametersAssignment_4_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//EntryPoint xmu2::EntryPoint:
		//	'entry' rule=[xmu2::ModelRule|NAME] '(' parameters+=EntryData ("," parameters+=EntryData)* ')'
		@Override public ParserRule getRule() { return rule; }
		
		//'entry' rule=[xmu2::ModelRule|NAME] '(' parameters+=EntryData ("," parameters+=EntryData)* ')'
		public Group getGroup() { return cGroup; }
		
		//'entry'
		public Keyword getEntryKeyword_0() { return cEntryKeyword_0; }
		
		//rule=[xmu2::ModelRule|NAME]
		public Assignment getRuleAssignment_1() { return cRuleAssignment_1; }
		
		//[xmu2::ModelRule|NAME]
		public CrossReference getRuleModelRuleCrossReference_1_0() { return cRuleModelRuleCrossReference_1_0; }
		
		//NAME
		public RuleCall getRuleModelRuleNAMETerminalRuleCall_1_0_1() { return cRuleModelRuleNAMETerminalRuleCall_1_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//parameters+=EntryData
		public Assignment getParametersAssignment_3() { return cParametersAssignment_3; }
		
		//EntryData
		public RuleCall getParametersEntryDataParserRuleCall_3_0() { return cParametersEntryDataParserRuleCall_3_0; }
		
		//("," parameters+=EntryData)*
		public Group getGroup_4() { return cGroup_4; }
		
		//","
		public Keyword getCommaKeyword_4_0() { return cCommaKeyword_4_0; }
		
		//parameters+=EntryData
		public Assignment getParametersAssignment_4_1() { return cParametersAssignment_4_1; }
		
		//EntryData
		public RuleCall getParametersEntryDataParserRuleCall_4_1_0() { return cParametersEntryDataParserRuleCall_4_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_5() { return cRightParenthesisKeyword_5; }
	}
	public class EntryDataElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.EntryData");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTagAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTagTagEnumRuleCall_0_0 = (RuleCall)cTagAssignment_0.eContents().get(0);
		private final Keyword cLeftSquareBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cIndexAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cIndexINTTerminalRuleCall_2_0 = (RuleCall)cIndexAssignment_2.eContents().get(0);
		private final Assignment cFragmentAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cFragmentOBJ_URITerminalRuleCall_3_0 = (RuleCall)cFragmentAssignment_3.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//EntryData xmu2::EntryData:
		//	tag=Tag? '[' index=INT ^fragment=OBJ_URI? ']'
		@Override public ParserRule getRule() { return rule; }
		
		//tag=Tag? '[' index=INT ^fragment=OBJ_URI? ']'
		public Group getGroup() { return cGroup; }
		
		//tag=Tag?
		public Assignment getTagAssignment_0() { return cTagAssignment_0; }
		
		//Tag
		public RuleCall getTagTagEnumRuleCall_0_0() { return cTagTagEnumRuleCall_0_0; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1() { return cLeftSquareBracketKeyword_1; }
		
		//index=INT
		public Assignment getIndexAssignment_2() { return cIndexAssignment_2; }
		
		//INT
		public RuleCall getIndexINTTerminalRuleCall_2_0() { return cIndexINTTerminalRuleCall_2_0; }
		
		//^fragment=OBJ_URI?
		public Assignment getFragmentAssignment_3() { return cFragmentAssignment_3; }
		
		//OBJ_URI
		public RuleCall getFragmentOBJ_URITerminalRuleCall_3_0() { return cFragmentOBJ_URITerminalRuleCall_3_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_4() { return cRightSquareBracketKeyword_4; }
	}
	public class AbstractRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.AbstractRule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cArithmeticRuleParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cModelRuleParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AbstractRule xmu2::AbstractRule:
		//	ArithmeticRule | ModelRule
		@Override public ParserRule getRule() { return rule; }
		
		//ArithmeticRule | ModelRule
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ArithmeticRule
		public RuleCall getArithmeticRuleParserRuleCall_0() { return cArithmeticRuleParserRuleCall_0; }
		
		//ModelRule
		public RuleCall getModelRuleParserRuleCall_1() { return cModelRuleParserRuleCall_1; }
	}
	public class ModelRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ModelRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cRuleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameNAMETerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_3_0_0 = (RuleCall)cParametersAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParametersAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_3_1_1_0 = (RuleCall)cParametersAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Group cGroup_6 = (Group)cGroup.eContents().get(6);
		private final Assignment cVariableDeclarationsAssignment_6_0 = (Assignment)cGroup_6.eContents().get(0);
		private final RuleCall cVariableDeclarationsConcreteVariableDeclarationParserRuleCall_6_0_0 = (RuleCall)cVariableDeclarationsAssignment_6_0.eContents().get(0);
		private final Keyword cSemicolonKeyword_6_1 = (Keyword)cGroup_6.eContents().get(1);
		private final Assignment cStatementAssignment_7 = (Assignment)cGroup.eContents().get(7);
		private final RuleCall cStatementStatementParserRuleCall_7_0 = (RuleCall)cStatementAssignment_7.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_8 = (Keyword)cGroup.eContents().get(8);
		
		//ModelRule xmu2::ModelRule:
		//	'rule' name=NAME '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '{'
		//	(variableDeclarations+=ConcreteVariableDeclaration ';')*
		//	statement=Statement?
		//	'}'
		@Override public ParserRule getRule() { return rule; }
		
		//'rule' name=NAME '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '{'
		//(variableDeclarations+=ConcreteVariableDeclaration ';')* statement=Statement? '}'
		public Group getGroup() { return cGroup; }
		
		//'rule'
		public Keyword getRuleKeyword_0() { return cRuleKeyword_0; }
		
		//name=NAME
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//NAME
		public RuleCall getNameNAMETerminalRuleCall_1_0() { return cNameNAMETerminalRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(parameters+=Parameter (',' parameters+=Parameter)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_3_0() { return cParametersAssignment_3_0; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_3_0_0() { return cParametersParameterParserRuleCall_3_0_0; }
		
		//(',' parameters+=Parameter)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_3_1_1() { return cParametersAssignment_3_1_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_3_1_1_0() { return cParametersParameterParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//(variableDeclarations+=ConcreteVariableDeclaration ';')*
		public Group getGroup_6() { return cGroup_6; }
		
		//variableDeclarations+=ConcreteVariableDeclaration
		public Assignment getVariableDeclarationsAssignment_6_0() { return cVariableDeclarationsAssignment_6_0; }
		
		//ConcreteVariableDeclaration
		public RuleCall getVariableDeclarationsConcreteVariableDeclarationParserRuleCall_6_0_0() { return cVariableDeclarationsConcreteVariableDeclarationParserRuleCall_6_0_0; }
		
		//';'
		public Keyword getSemicolonKeyword_6_1() { return cSemicolonKeyword_6_1; }
		
		//statement=Statement?
		public Assignment getStatementAssignment_7() { return cStatementAssignment_7; }
		
		//Statement
		public RuleCall getStatementStatementParserRuleCall_7_0() { return cStatementStatementParserRuleCall_7_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_8() { return cRightCurlyBracketKeyword_8; }
	}
	public class ArithmeticRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ArithmeticRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFunctionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameNAMETerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParametersParameterParserRuleCall_3_0_0 = (RuleCall)cParametersAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParametersAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParametersParameterParserRuleCall_3_1_1_0 = (RuleCall)cParametersAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Keyword cLeftCurlyBracketKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cStatementsAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cStatementsStatementParserRuleCall_6_0 = (RuleCall)cStatementsAssignment_6.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_7 = (Keyword)cGroup.eContents().get(7);
		
		//ArithmeticRule xmu2::ArithmeticRule:
		//	'function' name=NAME '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '{'
		//	statements+=Statement*
		//	'}'
		@Override public ParserRule getRule() { return rule; }
		
		//'function' name=NAME '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '{' statements+=Statement* '}'
		public Group getGroup() { return cGroup; }
		
		//'function'
		public Keyword getFunctionKeyword_0() { return cFunctionKeyword_0; }
		
		//name=NAME
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//NAME
		public RuleCall getNameNAMETerminalRuleCall_1_0() { return cNameNAMETerminalRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(parameters+=Parameter (',' parameters+=Parameter)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_3_0() { return cParametersAssignment_3_0; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_3_0_0() { return cParametersParameterParserRuleCall_3_0_0; }
		
		//(',' parameters+=Parameter)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//parameters+=Parameter
		public Assignment getParametersAssignment_3_1_1() { return cParametersAssignment_3_1_1; }
		
		//Parameter
		public RuleCall getParametersParameterParserRuleCall_3_1_1_0() { return cParametersParameterParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_5() { return cLeftCurlyBracketKeyword_5; }
		
		//statements+=Statement*
		public Assignment getStatementsAssignment_6() { return cStatementsAssignment_6; }
		
		//Statement
		public RuleCall getStatementsStatementParserRuleCall_6_0() { return cStatementsStatementParserRuleCall_6_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_7() { return cRightCurlyBracketKeyword_7; }
	}
	public class ParameterElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Parameter");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTagAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTagTagEnumRuleCall_0_0 = (RuleCall)cTagAssignment_0.eContents().get(0);
		private final Assignment cNameAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNameNAMETerminalRuleCall_1_0 = (RuleCall)cNameAssignment_1.eContents().get(0);
		private final Keyword cColonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cTypeAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final CrossReference cTypeEClassifierCrossReference_3_0 = (CrossReference)cTypeAssignment_3.eContents().get(0);
		private final RuleCall cTypeEClassifierTypeParserRuleCall_3_0_1 = (RuleCall)cTypeEClassifierCrossReference_3_0.eContents().get(1);
		
		//Parameter xmu2::Parameter:
		//	tag=Tag? name=NAME ':' type=[ecore::EClassifier|Type]
		@Override public ParserRule getRule() { return rule; }
		
		//tag=Tag? name=NAME ':' type=[ecore::EClassifier|Type]
		public Group getGroup() { return cGroup; }
		
		//tag=Tag?
		public Assignment getTagAssignment_0() { return cTagAssignment_0; }
		
		//Tag
		public RuleCall getTagTagEnumRuleCall_0_0() { return cTagTagEnumRuleCall_0_0; }
		
		//name=NAME
		public Assignment getNameAssignment_1() { return cNameAssignment_1; }
		
		//NAME
		public RuleCall getNameNAMETerminalRuleCall_1_0() { return cNameNAMETerminalRuleCall_1_0; }
		
		//':'
		public Keyword getColonKeyword_2() { return cColonKeyword_2; }
		
		//type=[ecore::EClassifier|Type]
		public Assignment getTypeAssignment_3() { return cTypeAssignment_3; }
		
		//[ecore::EClassifier|Type]
		public CrossReference getTypeEClassifierCrossReference_3_0() { return cTypeEClassifierCrossReference_3_0; }
		
		//Type
		public RuleCall getTypeEClassifierTypeParserRuleCall_3_0_1() { return cTypeEClassifierTypeParserRuleCall_3_0_1; }
	}
	public class TypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Type");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPRIMITIVE_TYPETerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPATH_NAMETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Type:
		//	PRIMITIVE_TYPE | PATH_NAME;
		@Override public ParserRule getRule() { return rule; }
		
		//PRIMITIVE_TYPE | PATH_NAME
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PRIMITIVE_TYPE
		public RuleCall getPRIMITIVE_TYPETerminalRuleCall_0() { return cPRIMITIVE_TYPETerminalRuleCall_0; }
		
		//PATH_NAME
		public RuleCall getPATH_NAMETerminalRuleCall_1() { return cPATH_NAMETerminalRuleCall_1; }
	}
	public class ConcreteVariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ConcreteVariableDeclaration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNameNAMETerminalRuleCall_0_0 = (RuleCall)cNameAssignment_0.eContents().get(0);
		private final Keyword cColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cTypeAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cTypeEClassifierCrossReference_2_0 = (CrossReference)cTypeAssignment_2.eContents().get(0);
		private final RuleCall cTypeEClassifierTypeParserRuleCall_2_0_1 = (RuleCall)cTypeEClassifierCrossReference_2_0.eContents().get(1);
		
		//ConcreteVariableDeclaration xmu2::ConcreteVariableDeclaration:
		//	name=NAME ':' type=[ecore::EClassifier|Type]
		@Override public ParserRule getRule() { return rule; }
		
		//name=NAME ':' type=[ecore::EClassifier|Type]
		public Group getGroup() { return cGroup; }
		
		//name=NAME
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//NAME
		public RuleCall getNameNAMETerminalRuleCall_0_0() { return cNameNAMETerminalRuleCall_0_0; }
		
		//':'
		public Keyword getColonKeyword_1() { return cColonKeyword_1; }
		
		//type=[ecore::EClassifier|Type]
		public Assignment getTypeAssignment_2() { return cTypeAssignment_2; }
		
		//[ecore::EClassifier|Type]
		public CrossReference getTypeEClassifierCrossReference_2_0() { return cTypeEClassifierCrossReference_2_0; }
		
		//Type
		public RuleCall getTypeEClassifierTypeParserRuleCall_2_0_1() { return cTypeEClassifierTypeParserRuleCall_2_0_1; }
	}
	public class PatternElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Pattern");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRootAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRootPatternNodeParserRuleCall_0_0 = (RuleCall)cRootAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cLeftSquareBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cGuardAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cGuardExpressionParserRuleCall_1_1_0 = (RuleCall)cGuardAssignment_1_1.eContents().get(0);
		private final Keyword cRightSquareBracketKeyword_1_2 = (Keyword)cGroup_1.eContents().get(2);
		
		//// pattern
		//Pattern xmu2pattern::Pattern:
		//	root=PatternNode ('[' guard=Expression ']')?
		@Override public ParserRule getRule() { return rule; }
		
		//root=PatternNode ('[' guard=Expression ']')?
		public Group getGroup() { return cGroup; }
		
		//root=PatternNode
		public Assignment getRootAssignment_0() { return cRootAssignment_0; }
		
		//PatternNode
		public RuleCall getRootPatternNodeParserRuleCall_0_0() { return cRootPatternNodeParserRuleCall_0_0; }
		
		//('[' guard=Expression ']')?
		public Group getGroup_1() { return cGroup_1; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword_1_0() { return cLeftSquareBracketKeyword_1_0; }
		
		//guard=Expression
		public Assignment getGuardAssignment_1_1() { return cGuardAssignment_1_1; }
		
		//Expression
		public RuleCall getGuardExpressionParserRuleCall_1_1_0() { return cGuardExpressionParserRuleCall_1_1_0; }
		
		//']'
		public Keyword getRightSquareBracketKeyword_1_2() { return cRightSquareBracketKeyword_1_2; }
	}
	public class PatternNodeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.PatternNode");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPatternNodeAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cVariableAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cVariableConcreteVariableDeclarationParserRuleCall_1_0 = (RuleCall)cVariableAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cLeftCurlyBracketKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cExpressionsAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final RuleCall cExpressionsPatternExpressionParserRuleCall_2_1_0_0 = (RuleCall)cExpressionsAssignment_2_1_0.eContents().get(0);
		private final Group cGroup_2_1_1 = (Group)cGroup_2_1.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_1_0 = (Keyword)cGroup_2_1_1.eContents().get(0);
		private final Assignment cExpressionsAssignment_2_1_1_1 = (Assignment)cGroup_2_1_1.eContents().get(1);
		private final RuleCall cExpressionsPatternExpressionParserRuleCall_2_1_1_1_0 = (RuleCall)cExpressionsAssignment_2_1_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_2_2 = (Keyword)cGroup_2.eContents().get(2);
		
		//PatternNode xmu2pattern::PatternNode:
		//	{xmu2pattern::PatternNode} variable=ConcreteVariableDeclaration ('{' (expressions+=PatternExpression (','
		//	expressions+=PatternExpression)*)? '}')?
		@Override public ParserRule getRule() { return rule; }
		
		//{xmu2pattern::PatternNode} variable=ConcreteVariableDeclaration ('{' (expressions+=PatternExpression (','
		//expressions+=PatternExpression)*)? '}')?
		public Group getGroup() { return cGroup; }
		
		//{xmu2pattern::PatternNode}
		public Action getPatternNodeAction_0() { return cPatternNodeAction_0; }
		
		//variable=ConcreteVariableDeclaration
		public Assignment getVariableAssignment_1() { return cVariableAssignment_1; }
		
		//ConcreteVariableDeclaration
		public RuleCall getVariableConcreteVariableDeclarationParserRuleCall_1_0() { return cVariableConcreteVariableDeclarationParserRuleCall_1_0; }
		
		//('{' (expressions+=PatternExpression (',' expressions+=PatternExpression)*)? '}')?
		public Group getGroup_2() { return cGroup_2; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_2_0() { return cLeftCurlyBracketKeyword_2_0; }
		
		//(expressions+=PatternExpression (',' expressions+=PatternExpression)*)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//expressions+=PatternExpression
		public Assignment getExpressionsAssignment_2_1_0() { return cExpressionsAssignment_2_1_0; }
		
		//PatternExpression
		public RuleCall getExpressionsPatternExpressionParserRuleCall_2_1_0_0() { return cExpressionsPatternExpressionParserRuleCall_2_1_0_0; }
		
		//(',' expressions+=PatternExpression)*
		public Group getGroup_2_1_1() { return cGroup_2_1_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_1_0() { return cCommaKeyword_2_1_1_0; }
		
		//expressions+=PatternExpression
		public Assignment getExpressionsAssignment_2_1_1_1() { return cExpressionsAssignment_2_1_1_1; }
		
		//PatternExpression
		public RuleCall getExpressionsPatternExpressionParserRuleCall_2_1_1_1_0() { return cExpressionsPatternExpressionParserRuleCall_2_1_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_2_2() { return cRightCurlyBracketKeyword_2_2; }
	}
	public class PatternExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.PatternExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPropertyPatternExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cObjectPatternExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//PatternExpression xmu2pattern::PatternExpression:
		//	=> PropertyPatternExpression
		//	| ObjectPatternExpression
		@Override public ParserRule getRule() { return rule; }
		
		//=> PropertyPatternExpression | ObjectPatternExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> PropertyPatternExpression
		public RuleCall getPropertyPatternExpressionParserRuleCall_0() { return cPropertyPatternExpressionParserRuleCall_0; }
		
		//ObjectPatternExpression
		public RuleCall getObjectPatternExpressionParserRuleCall_1() { return cObjectPatternExpressionParserRuleCall_1; }
	}
	public class ObjectPatternExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ObjectPatternExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cObjectPatternExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFeatureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFeatureEStructuralFeatureCrossReference_1_0 = (CrossReference)cFeatureAssignment_1.eContents().get(0);
		private final RuleCall cFeatureEStructuralFeatureNAMETerminalRuleCall_1_0_1 = (RuleCall)cFeatureEStructuralFeatureCrossReference_1_0.eContents().get(1);
		private final Assignment cSelectorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSelectorLoopPathParserRuleCall_2_0 = (RuleCall)cSelectorAssignment_2.eContents().get(0);
		private final Assignment cPositionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPositionPositionPathParserRuleCall_3_0 = (RuleCall)cPositionAssignment_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cNullableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cNullableQuestionMarkKeyword_5_0 = (Keyword)cNullableAssignment_5.eContents().get(0);
		private final Assignment cTargetNodeAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTargetNodePatternNodeParserRuleCall_6_0 = (RuleCall)cTargetNodeAssignment_6.eContents().get(0);
		
		//ObjectPatternExpression xmu2pattern::ObjectPatternExpression:
		//	{xmu2pattern::ObjectPatternExpression} feature=[ecore::EStructuralFeature|NAME] selector=LoopPath?
		//	position=PositionPath? '=' nullable?='?'? targetNode=PatternNode
		@Override public ParserRule getRule() { return rule; }
		
		//{xmu2pattern::ObjectPatternExpression} feature=[ecore::EStructuralFeature|NAME] selector=LoopPath?
		//position=PositionPath? '=' nullable?='?'? targetNode=PatternNode
		public Group getGroup() { return cGroup; }
		
		//{xmu2pattern::ObjectPatternExpression}
		public Action getObjectPatternExpressionAction_0() { return cObjectPatternExpressionAction_0; }
		
		//feature=[ecore::EStructuralFeature|NAME]
		public Assignment getFeatureAssignment_1() { return cFeatureAssignment_1; }
		
		//[ecore::EStructuralFeature|NAME]
		public CrossReference getFeatureEStructuralFeatureCrossReference_1_0() { return cFeatureEStructuralFeatureCrossReference_1_0; }
		
		//NAME
		public RuleCall getFeatureEStructuralFeatureNAMETerminalRuleCall_1_0_1() { return cFeatureEStructuralFeatureNAMETerminalRuleCall_1_0_1; }
		
		//selector=LoopPath?
		public Assignment getSelectorAssignment_2() { return cSelectorAssignment_2; }
		
		//LoopPath
		public RuleCall getSelectorLoopPathParserRuleCall_2_0() { return cSelectorLoopPathParserRuleCall_2_0; }
		
		//position=PositionPath?
		public Assignment getPositionAssignment_3() { return cPositionAssignment_3; }
		
		//PositionPath
		public RuleCall getPositionPositionPathParserRuleCall_3_0() { return cPositionPositionPathParserRuleCall_3_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }
		
		//nullable?='?'?
		public Assignment getNullableAssignment_5() { return cNullableAssignment_5; }
		
		//'?'
		public Keyword getNullableQuestionMarkKeyword_5_0() { return cNullableQuestionMarkKeyword_5_0; }
		
		//targetNode=PatternNode
		public Assignment getTargetNodeAssignment_6() { return cTargetNodeAssignment_6; }
		
		//PatternNode
		public RuleCall getTargetNodePatternNodeParserRuleCall_6_0() { return cTargetNodePatternNodeParserRuleCall_6_0; }
	}
	public class PropertyPatternExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.PropertyPatternExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cPropertyPatternExpressionAction_0 = (Action)cGroup.eContents().get(0);
		private final Assignment cFeatureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final CrossReference cFeatureEStructuralFeatureCrossReference_1_0 = (CrossReference)cFeatureAssignment_1.eContents().get(0);
		private final RuleCall cFeatureEStructuralFeatureNAMETerminalRuleCall_1_0_1 = (RuleCall)cFeatureEStructuralFeatureCrossReference_1_0.eContents().get(1);
		private final Assignment cSelectorAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSelectorLoopPathParserRuleCall_2_0 = (RuleCall)cSelectorAssignment_2.eContents().get(0);
		private final Assignment cPositionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cPositionPositionPathParserRuleCall_3_0 = (RuleCall)cPositionAssignment_3.eContents().get(0);
		private final Keyword cEqualsSignKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cNullableAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final Keyword cNullableQuestionMarkKeyword_5_0 = (Keyword)cNullableAssignment_5.eContents().get(0);
		private final Assignment cTargetExpressionAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTargetExpressionExpressionParserRuleCall_6_0 = (RuleCall)cTargetExpressionAssignment_6.eContents().get(0);
		
		//PropertyPatternExpression xmu2pattern::PropertyPatternExpression:
		//	{xmu2pattern::PropertyPatternExpression} feature=[ecore::EStructuralFeature|NAME] selector=LoopPath?
		//	position=PositionPath? '=' nullable?='?'? targetExpression=Expression
		@Override public ParserRule getRule() { return rule; }
		
		//{xmu2pattern::PropertyPatternExpression} feature=[ecore::EStructuralFeature|NAME] selector=LoopPath?
		//position=PositionPath? '=' nullable?='?'? targetExpression=Expression
		public Group getGroup() { return cGroup; }
		
		//{xmu2pattern::PropertyPatternExpression}
		public Action getPropertyPatternExpressionAction_0() { return cPropertyPatternExpressionAction_0; }
		
		//feature=[ecore::EStructuralFeature|NAME]
		public Assignment getFeatureAssignment_1() { return cFeatureAssignment_1; }
		
		//[ecore::EStructuralFeature|NAME]
		public CrossReference getFeatureEStructuralFeatureCrossReference_1_0() { return cFeatureEStructuralFeatureCrossReference_1_0; }
		
		//NAME
		public RuleCall getFeatureEStructuralFeatureNAMETerminalRuleCall_1_0_1() { return cFeatureEStructuralFeatureNAMETerminalRuleCall_1_0_1; }
		
		//selector=LoopPath?
		public Assignment getSelectorAssignment_2() { return cSelectorAssignment_2; }
		
		//LoopPath
		public RuleCall getSelectorLoopPathParserRuleCall_2_0() { return cSelectorLoopPathParserRuleCall_2_0; }
		
		//position=PositionPath?
		public Assignment getPositionAssignment_3() { return cPositionAssignment_3; }
		
		//PositionPath
		public RuleCall getPositionPositionPathParserRuleCall_3_0() { return cPositionPositionPathParserRuleCall_3_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_4() { return cEqualsSignKeyword_4; }
		
		//nullable?='?'?
		public Assignment getNullableAssignment_5() { return cNullableAssignment_5; }
		
		//'?'
		public Keyword getNullableQuestionMarkKeyword_5_0() { return cNullableQuestionMarkKeyword_5_0; }
		
		//targetExpression=Expression
		public Assignment getTargetExpressionAssignment_6() { return cTargetExpressionAssignment_6; }
		
		//Expression
		public RuleCall getTargetExpressionExpressionParserRuleCall_6_0() { return cTargetExpressionExpressionParserRuleCall_6_0; }
	}
	public class ReflectiveVariableDeclarationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ReflectiveVariableDeclaration");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameNAMETerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ReflectiveVariableDeclaration xmu2::ReflectiveVariableDeclaration:
		//	name=NAME
		@Override public ParserRule getRule() { return rule; }
		
		//name=NAME
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//NAME
		public RuleCall getNameNAMETerminalRuleCall_0() { return cNameNAMETerminalRuleCall_0; }
	}
	public class LoopPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.LoopPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorLoopOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cVariableAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cVariableConcreteVariableDeclarationParserRuleCall_3_0 = (RuleCall)cVariableAssignment_3.eContents().get(0);
		private final Keyword cVerticalLineKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cBodyAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cBodyExpressionParserRuleCall_5_0 = (RuleCall)cBodyAssignment_5.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//// path
		//LoopPath xmu2expression::LoopPath:
		//	'->' operator=LoopOperator '(' variable=ConcreteVariableDeclaration '|' body=Expression ')'
		@Override public ParserRule getRule() { return rule; }
		
		//'->' operator=LoopOperator '(' variable=ConcreteVariableDeclaration '|' body=Expression ')'
		public Group getGroup() { return cGroup; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0() { return cHyphenMinusGreaterThanSignKeyword_0; }
		
		//operator=LoopOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }
		
		//LoopOperator
		public RuleCall getOperatorLoopOperatorEnumRuleCall_1_0() { return cOperatorLoopOperatorEnumRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//variable=ConcreteVariableDeclaration
		public Assignment getVariableAssignment_3() { return cVariableAssignment_3; }
		
		//ConcreteVariableDeclaration
		public RuleCall getVariableConcreteVariableDeclarationParserRuleCall_3_0() { return cVariableConcreteVariableDeclarationParserRuleCall_3_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_4() { return cVerticalLineKeyword_4; }
		
		//body=Expression
		public Assignment getBodyAssignment_5() { return cBodyAssignment_5; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_5_0() { return cBodyExpressionParserRuleCall_5_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_6() { return cRightParenthesisKeyword_6; }
	}
	public class PositionPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.PositionPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypePositionOperatorEnumRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueExpressionParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//PositionPath xmu2expression::PositionPath:
		//	'->' type=PositionOperator '(' value=Expression? ')'
		@Override public ParserRule getRule() { return rule; }
		
		//'->' type=PositionOperator '(' value=Expression? ')'
		public Group getGroup() { return cGroup; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_0() { return cHyphenMinusGreaterThanSignKeyword_0; }
		
		//type=PositionOperator
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//PositionOperator
		public RuleCall getTypePositionOperatorEnumRuleCall_1_0() { return cTypePositionOperatorEnumRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//value=Expression?
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_3_0() { return cValueExpressionParserRuleCall_3_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class FeaturePathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.FeaturePath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFeatureAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFeatureNAMETerminalRuleCall_1_0 = (RuleCall)cFeatureAssignment_1.eContents().get(0);
		
		//FeaturePath xmu2expression::FeaturePath:
		//	'.' feature=NAME
		@Override public ParserRule getRule() { return rule; }
		
		//'.' feature=NAME
		public Group getGroup() { return cGroup; }
		
		//'.'
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//feature=NAME
		public Assignment getFeatureAssignment_1() { return cFeatureAssignment_1; }
		
		//NAME
		public RuleCall getFeatureNAMETerminalRuleCall_1_0() { return cFeatureNAMETerminalRuleCall_1_0; }
	}
	public class OperationPathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.OperationPath");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFullStopKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cOperationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperationNAMETerminalRuleCall_1_0 = (RuleCall)cOperationAssignment_1.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Assignment cParametersAssignment_3_0 = (Assignment)cGroup_3.eContents().get(0);
		private final RuleCall cParametersExpressionParserRuleCall_3_0_0 = (RuleCall)cParametersAssignment_3_0.eContents().get(0);
		private final Group cGroup_3_1 = (Group)cGroup_3.eContents().get(1);
		private final Keyword cCommaKeyword_3_1_0 = (Keyword)cGroup_3_1.eContents().get(0);
		private final Assignment cParametersAssignment_3_1_1 = (Assignment)cGroup_3_1.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_3_1_1_0 = (RuleCall)cParametersAssignment_3_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//OperationPath xmu2expression::OperationPath:
		//	'.' operation=NAME '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
		@Override public ParserRule getRule() { return rule; }
		
		//'.' operation=NAME '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//'.'
		public Keyword getFullStopKeyword_0() { return cFullStopKeyword_0; }
		
		//operation=NAME
		public Assignment getOperationAssignment_1() { return cOperationAssignment_1; }
		
		//NAME
		public RuleCall getOperationNAMETerminalRuleCall_1_0() { return cOperationNAMETerminalRuleCall_1_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_2() { return cLeftParenthesisKeyword_2; }
		
		//(parameters+=Expression (',' parameters+=Expression)*)?
		public Group getGroup_3() { return cGroup_3; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_3_0() { return cParametersAssignment_3_0; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_3_0_0() { return cParametersExpressionParserRuleCall_3_0_0; }
		
		//(',' parameters+=Expression)*
		public Group getGroup_3_1() { return cGroup_3_1; }
		
		//','
		public Keyword getCommaKeyword_3_1_0() { return cCommaKeyword_3_1_0; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_3_1_1() { return cParametersAssignment_3_1_1; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_3_1_1_0() { return cParametersExpressionParserRuleCall_3_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_4() { return cRightParenthesisKeyword_4; }
	}
	public class VariableExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.VariableExpression");
		private final Assignment cVariableAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cVariableNAMETerminalRuleCall_0 = (RuleCall)cVariableAssignment.eContents().get(0);
		
		//// expression
		//VariableExpression xmu2expression::VariableExpression:
		//	variable=NAME
		@Override public ParserRule getRule() { return rule; }
		
		//variable=NAME
		public Assignment getVariableAssignment() { return cVariableAssignment; }
		
		//NAME
		public RuleCall getVariableNAMETerminalRuleCall_0() { return cVariableNAMETerminalRuleCall_0; }
	}
	public class PathElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Path");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLoopPathParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPositionPathParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFeaturePathParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cOperationPathParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		////PathExpression returns xmu2expression::PathExpression :
		////	host = AtomicExpression (path+=Path)+
		////;
		//Path xmu2expression::Path:
		//	=> LoopPath
		//	| PositionPath
		//	| => FeaturePath
		//	| OperationPath
		@Override public ParserRule getRule() { return rule; }
		
		//=> LoopPath | PositionPath | => FeaturePath | OperationPath
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> LoopPath
		public RuleCall getLoopPathParserRuleCall_0() { return cLoopPathParserRuleCall_0; }
		
		//PositionPath
		public RuleCall getPositionPathParserRuleCall_1() { return cPositionPathParserRuleCall_1; }
		
		//=> FeaturePath
		public RuleCall getFeaturePathParserRuleCall_2() { return cFeaturePathParserRuleCall_2; }
		
		//OperationPath
		public RuleCall getOperationPathParserRuleCall_3() { return cOperationPathParserRuleCall_3; }
	}
	public class EmptyExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.EmptyExpression");
		private final Assignment cTypeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cTypeEmptyValueEnumRuleCall_0 = (RuleCall)cTypeAssignment.eContents().get(0);
		
		//EmptyExpression xmu2expression::EmptyExpression:
		//	type=EmptyValue
		@Override public ParserRule getRule() { return rule; }
		
		//type=EmptyValue
		public Assignment getTypeAssignment() { return cTypeAssignment; }
		
		//EmptyValue
		public RuleCall getTypeEmptyValueEnumRuleCall_0() { return cTypeEmptyValueEnumRuleCall_0; }
	}
	public class StringLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.StringLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueSTRINGTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//StringLiteralExpression xmu2expression::StringLiteralExpression:
		//	value=STRING
		@Override public ParserRule getRule() { return rule; }
		
		//value=STRING
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//STRING
		public RuleCall getValueSTRINGTerminalRuleCall_0() { return cValueSTRINGTerminalRuleCall_0; }
	}
	public class IntegerLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.IntegerLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueINTTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//IntegerLiteralExpression xmu2expression::IntegerLiteralExpression:
		//	value=INT
		@Override public ParserRule getRule() { return rule; }
		
		//value=INT
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//INT
		public RuleCall getValueINTTerminalRuleCall_0() { return cValueINTTerminalRuleCall_0; }
	}
	public class BooleanLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.BooleanLiteralExpression");
		private final Assignment cValueAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValueBOOLEANTerminalRuleCall_0 = (RuleCall)cValueAssignment.eContents().get(0);
		
		//BooleanLiteralExpression xmu2expression::BooleanLiteralExpression:
		//	value=BOOLEAN
		@Override public ParserRule getRule() { return rule; }
		
		//value=BOOLEAN
		public Assignment getValueAssignment() { return cValueAssignment; }
		
		//BOOLEAN
		public RuleCall getValueBOOLEANTerminalRuleCall_0() { return cValueBOOLEANTerminalRuleCall_0; }
	}
	public class EnumLiteralExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.EnumLiteralExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cTypeEEnumCrossReference_0_0 = (CrossReference)cTypeAssignment_0.eContents().get(0);
		private final RuleCall cTypeEEnumTypeParserRuleCall_0_0_1 = (RuleCall)cTypeEEnumCrossReference_0_0.eContents().get(1);
		private final Keyword cColonColonKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final CrossReference cValueEEnumLiteralCrossReference_2_0 = (CrossReference)cValueAssignment_2.eContents().get(0);
		private final RuleCall cValueEEnumLiteralNAMETerminalRuleCall_2_0_1 = (RuleCall)cValueEEnumLiteralCrossReference_2_0.eContents().get(1);
		
		//EnumLiteralExpression xmu2expression::EnumLiteralExpression:
		//	type=[ecore::EEnum|Type] '::' value=[ecore::EEnumLiteral|NAME]
		@Override public ParserRule getRule() { return rule; }
		
		//type=[ecore::EEnum|Type] '::' value=[ecore::EEnumLiteral|NAME]
		public Group getGroup() { return cGroup; }
		
		//type=[ecore::EEnum|Type]
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//[ecore::EEnum|Type]
		public CrossReference getTypeEEnumCrossReference_0_0() { return cTypeEEnumCrossReference_0_0; }
		
		//Type
		public RuleCall getTypeEEnumTypeParserRuleCall_0_0_1() { return cTypeEEnumTypeParserRuleCall_0_0_1; }
		
		//'::'
		public Keyword getColonColonKeyword_1() { return cColonColonKeyword_1; }
		
		//value=[ecore::EEnumLiteral|NAME]
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//[ecore::EEnumLiteral|NAME]
		public CrossReference getValueEEnumLiteralCrossReference_2_0() { return cValueEEnumLiteralCrossReference_2_0; }
		
		//NAME
		public RuleCall getValueEEnumLiteralNAMETerminalRuleCall_2_0_1() { return cValueEEnumLiteralNAMETerminalRuleCall_2_0_1; }
	}
	public class ObjectURIExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ObjectURIExpression");
		private final Assignment cObjectAssignment = (Assignment)rule.eContents().get(1);
		private final CrossReference cObjectEObjectCrossReference_0 = (CrossReference)cObjectAssignment.eContents().get(0);
		private final RuleCall cObjectEObjectOBJ_URITerminalRuleCall_0_1 = (RuleCall)cObjectEObjectCrossReference_0.eContents().get(1);
		
		//ObjectURIExpression xmu2expression::ObjectURIExpression:
		//	object=[ecore::EObject|OBJ_URI]
		@Override public ParserRule getRule() { return rule; }
		
		//object=[ecore::EObject|OBJ_URI]
		public Assignment getObjectAssignment() { return cObjectAssignment; }
		
		//[ecore::EObject|OBJ_URI]
		public CrossReference getObjectEObjectCrossReference_0() { return cObjectEObjectCrossReference_0; }
		
		//OBJ_URI
		public RuleCall getObjectEObjectOBJ_URITerminalRuleCall_0_1() { return cObjectEObjectOBJ_URITerminalRuleCall_0_1; }
	}
	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.UnaryExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperatorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperatorUnaryOperatorEnumRuleCall_0_0 = (RuleCall)cOperatorAssignment_0.eContents().get(0);
		private final Assignment cBodyAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBodyUnaryExpressionChildParserRuleCall_1_0 = (RuleCall)cBodyAssignment_1.eContents().get(0);
		
		//UnaryExpression xmu2expression::UnaryExpression:
		//	operator=UnaryOperator body=UnaryExpressionChild
		@Override public ParserRule getRule() { return rule; }
		
		//operator=UnaryOperator body=UnaryExpressionChild
		public Group getGroup() { return cGroup; }
		
		//operator=UnaryOperator
		public Assignment getOperatorAssignment_0() { return cOperatorAssignment_0; }
		
		//UnaryOperator
		public RuleCall getOperatorUnaryOperatorEnumRuleCall_0_0() { return cOperatorUnaryOperatorEnumRuleCall_0_0; }
		
		//body=UnaryExpressionChild
		public Assignment getBodyAssignment_1() { return cBodyAssignment_1; }
		
		//UnaryExpressionChild
		public RuleCall getBodyUnaryExpressionChildParserRuleCall_1_0() { return cBodyUnaryExpressionChildParserRuleCall_1_0; }
	}
	public class UnaryExpressionChildElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.UnaryExpressionChild");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAtomicExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cPathExpressionHostAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Assignment cPathAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cPathPathParserRuleCall_1_1_0 = (RuleCall)cPathAssignment_1_1.eContents().get(0);
		private final Assignment cPathAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cPathPathParserRuleCall_1_2_0 = (RuleCall)cPathAssignment_1_2.eContents().get(0);
		
		//UnaryExpressionChild xmu2expression::UnaryExpressionChild:
		//	AtomicExpression ({xmu2expression::PathExpression.host=current} path+=Path path+=Path*)?
		@Override public ParserRule getRule() { return rule; }
		
		//AtomicExpression ({xmu2expression::PathExpression.host=current} path+=Path path+=Path*)?
		public Group getGroup() { return cGroup; }
		
		//AtomicExpression
		public RuleCall getAtomicExpressionParserRuleCall_0() { return cAtomicExpressionParserRuleCall_0; }
		
		//({xmu2expression::PathExpression.host=current} path+=Path path+=Path*)?
		public Group getGroup_1() { return cGroup_1; }
		
		//{xmu2expression::PathExpression.host=current}
		public Action getPathExpressionHostAction_1_0() { return cPathExpressionHostAction_1_0; }
		
		//path+=Path
		public Assignment getPathAssignment_1_1() { return cPathAssignment_1_1; }
		
		//Path
		public RuleCall getPathPathParserRuleCall_1_1_0() { return cPathPathParserRuleCall_1_1_0; }
		
		//path+=Path*
		public Assignment getPathAssignment_1_2() { return cPathAssignment_1_2; }
		
		//Path
		public RuleCall getPathPathParserRuleCall_1_2_0() { return cPathPathParserRuleCall_1_2_0; }
	}
	public class AtomicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.AtomicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final Action cParenExpressionAction_0_1 = (Action)cGroup_0.eContents().get(1);
		private final Assignment cBodyAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cBodyExpressionParserRuleCall_0_2_0 = (RuleCall)cBodyAssignment_0_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_0_3 = (Keyword)cGroup_0.eContents().get(3);
		private final RuleCall cVariableExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cConstantExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//AtomicExpression xmu2expression::AtomicExpression:
		//	'(' {xmu2expression::ParenExpression} body=Expression ')'
		//	| VariableExpression | ConstantExpression
		@Override public ParserRule getRule() { return rule; }
		
		//'(' {xmu2expression::ParenExpression} body=Expression ')' | VariableExpression | ConstantExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'(' {xmu2expression::ParenExpression} body=Expression ')'
		public Group getGroup_0() { return cGroup_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }
		
		//{xmu2expression::ParenExpression}
		public Action getParenExpressionAction_0_1() { return cParenExpressionAction_0_1; }
		
		//body=Expression
		public Assignment getBodyAssignment_0_2() { return cBodyAssignment_0_2; }
		
		//Expression
		public RuleCall getBodyExpressionParserRuleCall_0_2_0() { return cBodyExpressionParserRuleCall_0_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_0_3() { return cRightParenthesisKeyword_0_3; }
		
		//VariableExpression
		public RuleCall getVariableExpressionParserRuleCall_1() { return cVariableExpressionParserRuleCall_1; }
		
		//ConstantExpression
		public RuleCall getConstantExpressionParserRuleCall_2() { return cConstantExpressionParserRuleCall_2; }
	}
	public class ConstantExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ConstantExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEmptyExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cStringLiteralExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIntegerLiteralExpressionParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBooleanLiteralExpressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cEnumLiteralExpressionParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cObjectURIExpressionParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//ConstantExpression xmu2expression::ConstantExpression:
		//	EmptyExpression | StringLiteralExpression
		//	| IntegerLiteralExpression | BooleanLiteralExpression
		//	| EnumLiteralExpression | ObjectURIExpression
		@Override public ParserRule getRule() { return rule; }
		
		//EmptyExpression | StringLiteralExpression | IntegerLiteralExpression | BooleanLiteralExpression | EnumLiteralExpression
		//| ObjectURIExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EmptyExpression
		public RuleCall getEmptyExpressionParserRuleCall_0() { return cEmptyExpressionParserRuleCall_0; }
		
		//StringLiteralExpression
		public RuleCall getStringLiteralExpressionParserRuleCall_1() { return cStringLiteralExpressionParserRuleCall_1; }
		
		//IntegerLiteralExpression
		public RuleCall getIntegerLiteralExpressionParserRuleCall_2() { return cIntegerLiteralExpressionParserRuleCall_2; }
		
		//BooleanLiteralExpression
		public RuleCall getBooleanLiteralExpressionParserRuleCall_3() { return cBooleanLiteralExpressionParserRuleCall_3; }
		
		//EnumLiteralExpression
		public RuleCall getEnumLiteralExpressionParserRuleCall_4() { return cEnumLiteralExpressionParserRuleCall_4; }
		
		//ObjectURIExpression
		public RuleCall getObjectURIExpressionParserRuleCall_5() { return cObjectURIExpressionParserRuleCall_5; }
	}
	public class MultiplicativeExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.MultiplicativeExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperandsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperandsMultiplicativeExpressionChildParserRuleCall_0_0 = (RuleCall)cOperandsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorsMultiplicativeOperatorEnumRuleCall_1_0_0 = (RuleCall)cOperatorsAssignment_1_0.eContents().get(0);
		private final Assignment cOperandsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandsMultiplicativeExpressionChildParserRuleCall_1_1_0 = (RuleCall)cOperandsAssignment_1_1.eContents().get(0);
		
		//MultiplicativeExpression xmu2expression::MultiplicativeExpression:
		//	operands+=MultiplicativeExpressionChild (operators+=MultiplicativeOperator operands+=MultiplicativeExpressionChild)+
		@Override public ParserRule getRule() { return rule; }
		
		//operands+=MultiplicativeExpressionChild (operators+=MultiplicativeOperator operands+=MultiplicativeExpressionChild)+
		public Group getGroup() { return cGroup; }
		
		//operands+=MultiplicativeExpressionChild
		public Assignment getOperandsAssignment_0() { return cOperandsAssignment_0; }
		
		//MultiplicativeExpressionChild
		public RuleCall getOperandsMultiplicativeExpressionChildParserRuleCall_0_0() { return cOperandsMultiplicativeExpressionChildParserRuleCall_0_0; }
		
		//(operators+=MultiplicativeOperator operands+=MultiplicativeExpressionChild)+
		public Group getGroup_1() { return cGroup_1; }
		
		//operators+=MultiplicativeOperator
		public Assignment getOperatorsAssignment_1_0() { return cOperatorsAssignment_1_0; }
		
		//MultiplicativeOperator
		public RuleCall getOperatorsMultiplicativeOperatorEnumRuleCall_1_0_0() { return cOperatorsMultiplicativeOperatorEnumRuleCall_1_0_0; }
		
		//operands+=MultiplicativeExpressionChild
		public Assignment getOperandsAssignment_1_1() { return cOperandsAssignment_1_1; }
		
		//MultiplicativeExpressionChild
		public RuleCall getOperandsMultiplicativeExpressionChildParserRuleCall_1_1_0() { return cOperandsMultiplicativeExpressionChildParserRuleCall_1_1_0; }
	}
	public class MultiplicativeExpressionChildElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.MultiplicativeExpressionChild");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnaryExpressionChildParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//MultiplicativeExpressionChild xmu2expression::MultiplicativeExpressionChild:
		//	=> UnaryExpression
		//	| UnaryExpressionChild
		@Override public ParserRule getRule() { return rule; }
		
		//=> UnaryExpression | UnaryExpressionChild
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }
		
		//UnaryExpressionChild
		public RuleCall getUnaryExpressionChildParserRuleCall_1() { return cUnaryExpressionChildParserRuleCall_1; }
	}
	public class AdditiveExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.AdditiveExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperandsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperandsAdditiveExpressionChildParserRuleCall_0_0 = (RuleCall)cOperandsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cOperatorsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cOperatorsAdditiveOperatorEnumRuleCall_1_0_0 = (RuleCall)cOperatorsAssignment_1_0.eContents().get(0);
		private final Assignment cOperandsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandsAdditiveExpressionChildParserRuleCall_1_1_0 = (RuleCall)cOperandsAssignment_1_1.eContents().get(0);
		
		//AdditiveExpression xmu2expression::AdditiveExpression:
		//	operands+=AdditiveExpressionChild (operators+=AdditiveOperator operands+=AdditiveExpressionChild)+
		@Override public ParserRule getRule() { return rule; }
		
		//operands+=AdditiveExpressionChild (operators+=AdditiveOperator operands+=AdditiveExpressionChild)+
		public Group getGroup() { return cGroup; }
		
		//operands+=AdditiveExpressionChild
		public Assignment getOperandsAssignment_0() { return cOperandsAssignment_0; }
		
		//AdditiveExpressionChild
		public RuleCall getOperandsAdditiveExpressionChildParserRuleCall_0_0() { return cOperandsAdditiveExpressionChildParserRuleCall_0_0; }
		
		//(operators+=AdditiveOperator operands+=AdditiveExpressionChild)+
		public Group getGroup_1() { return cGroup_1; }
		
		//operators+=AdditiveOperator
		public Assignment getOperatorsAssignment_1_0() { return cOperatorsAssignment_1_0; }
		
		//AdditiveOperator
		public RuleCall getOperatorsAdditiveOperatorEnumRuleCall_1_0_0() { return cOperatorsAdditiveOperatorEnumRuleCall_1_0_0; }
		
		//operands+=AdditiveExpressionChild
		public Assignment getOperandsAssignment_1_1() { return cOperandsAssignment_1_1; }
		
		//AdditiveExpressionChild
		public RuleCall getOperandsAdditiveExpressionChildParserRuleCall_1_1_0() { return cOperandsAdditiveExpressionChildParserRuleCall_1_1_0; }
	}
	public class AdditiveExpressionChildElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.AdditiveExpressionChild");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cMultiplicativeExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMultiplicativeExpressionChildParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//AdditiveExpressionChild xmu2expression::AdditiveExpressionChild:
		//	=> MultiplicativeExpression
		//	| MultiplicativeExpressionChild
		@Override public ParserRule getRule() { return rule; }
		
		//=> MultiplicativeExpression | MultiplicativeExpressionChild
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> MultiplicativeExpression
		public RuleCall getMultiplicativeExpressionParserRuleCall_0() { return cMultiplicativeExpressionParserRuleCall_0; }
		
		//MultiplicativeExpressionChild
		public RuleCall getMultiplicativeExpressionChildParserRuleCall_1() { return cMultiplicativeExpressionChildParserRuleCall_1; }
	}
	public class RelationalExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.RelationalExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftRelationalExpressionChildParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Assignment cOperatorAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOperatorRelationalOperatorEnumRuleCall_1_0 = (RuleCall)cOperatorAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightRelationalExpressionChildParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		//RelationalExpression xmu2expression::RelationalExpression:
		//	left=RelationalExpressionChild operator=RelationalOperator right=RelationalExpressionChild
		@Override public ParserRule getRule() { return rule; }
		
		//left=RelationalExpressionChild operator=RelationalOperator right=RelationalExpressionChild
		public Group getGroup() { return cGroup; }
		
		//left=RelationalExpressionChild
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//RelationalExpressionChild
		public RuleCall getLeftRelationalExpressionChildParserRuleCall_0_0() { return cLeftRelationalExpressionChildParserRuleCall_0_0; }
		
		//operator=RelationalOperator
		public Assignment getOperatorAssignment_1() { return cOperatorAssignment_1; }
		
		//RelationalOperator
		public RuleCall getOperatorRelationalOperatorEnumRuleCall_1_0() { return cOperatorRelationalOperatorEnumRuleCall_1_0; }
		
		//right=RelationalExpressionChild
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//RelationalExpressionChild
		public RuleCall getRightRelationalExpressionChildParserRuleCall_2_0() { return cRightRelationalExpressionChildParserRuleCall_2_0; }
	}
	public class RelationalExpressionChildElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.RelationalExpressionChild");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAdditiveExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cAdditiveExpressionChildParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//RelationalExpressionChild xmu2expression::RelationalExpressionChild:
		//	=> AdditiveExpression
		//	| AdditiveExpressionChild
		@Override public ParserRule getRule() { return rule; }
		
		//=> AdditiveExpression | AdditiveExpressionChild
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> AdditiveExpression
		public RuleCall getAdditiveExpressionParserRuleCall_0() { return cAdditiveExpressionParserRuleCall_0; }
		
		//AdditiveExpressionChild
		public RuleCall getAdditiveExpressionChildParserRuleCall_1() { return cAdditiveExpressionChildParserRuleCall_1; }
	}
	public class BooleanAndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.BooleanAndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperandsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperandsBooleanAndExpressionChildParserRuleCall_0_0 = (RuleCall)cOperandsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cAndKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOperandsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandsBooleanAndExpressionChildParserRuleCall_1_1_0 = (RuleCall)cOperandsAssignment_1_1.eContents().get(0);
		
		//BooleanAndExpression xmu2expression::BooleanAndExpression:
		//	operands+=BooleanAndExpressionChild ('and' operands+=BooleanAndExpressionChild)+
		@Override public ParserRule getRule() { return rule; }
		
		//operands+=BooleanAndExpressionChild ('and' operands+=BooleanAndExpressionChild)+
		public Group getGroup() { return cGroup; }
		
		//operands+=BooleanAndExpressionChild
		public Assignment getOperandsAssignment_0() { return cOperandsAssignment_0; }
		
		//BooleanAndExpressionChild
		public RuleCall getOperandsBooleanAndExpressionChildParserRuleCall_0_0() { return cOperandsBooleanAndExpressionChildParserRuleCall_0_0; }
		
		//('and' operands+=BooleanAndExpressionChild)+
		public Group getGroup_1() { return cGroup_1; }
		
		//'and'
		public Keyword getAndKeyword_1_0() { return cAndKeyword_1_0; }
		
		//operands+=BooleanAndExpressionChild
		public Assignment getOperandsAssignment_1_1() { return cOperandsAssignment_1_1; }
		
		//BooleanAndExpressionChild
		public RuleCall getOperandsBooleanAndExpressionChildParserRuleCall_1_1_0() { return cOperandsBooleanAndExpressionChildParserRuleCall_1_1_0; }
	}
	public class BooleanAndExpressionChildElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.BooleanAndExpressionChild");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cRelationalExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cRelationalExpressionChildParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BooleanAndExpressionChild xmu2expression::BooleanAndExpressionChild:
		//	=> RelationalExpression
		//	| RelationalExpressionChild
		@Override public ParserRule getRule() { return rule; }
		
		//=> RelationalExpression | RelationalExpressionChild
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> RelationalExpression
		public RuleCall getRelationalExpressionParserRuleCall_0() { return cRelationalExpressionParserRuleCall_0; }
		
		//RelationalExpressionChild
		public RuleCall getRelationalExpressionChildParserRuleCall_1() { return cRelationalExpressionChildParserRuleCall_1; }
	}
	public class BooleanOrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.BooleanOrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOperandsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cOperandsBooleanOrExpressionChildParserRuleCall_0_0 = (RuleCall)cOperandsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cOrKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cOperandsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cOperandsBooleanOrExpressionChildParserRuleCall_1_1_0 = (RuleCall)cOperandsAssignment_1_1.eContents().get(0);
		
		//BooleanOrExpression xmu2expression::BooleanOrExpression:
		//	operands+=BooleanOrExpressionChild ('or' operands+=BooleanOrExpressionChild)+
		@Override public ParserRule getRule() { return rule; }
		
		//operands+=BooleanOrExpressionChild ('or' operands+=BooleanOrExpressionChild)+
		public Group getGroup() { return cGroup; }
		
		//operands+=BooleanOrExpressionChild
		public Assignment getOperandsAssignment_0() { return cOperandsAssignment_0; }
		
		//BooleanOrExpressionChild
		public RuleCall getOperandsBooleanOrExpressionChildParserRuleCall_0_0() { return cOperandsBooleanOrExpressionChildParserRuleCall_0_0; }
		
		//('or' operands+=BooleanOrExpressionChild)+
		public Group getGroup_1() { return cGroup_1; }
		
		//'or'
		public Keyword getOrKeyword_1_0() { return cOrKeyword_1_0; }
		
		//operands+=BooleanOrExpressionChild
		public Assignment getOperandsAssignment_1_1() { return cOperandsAssignment_1_1; }
		
		//BooleanOrExpressionChild
		public RuleCall getOperandsBooleanOrExpressionChildParserRuleCall_1_1_0() { return cOperandsBooleanOrExpressionChildParserRuleCall_1_1_0; }
	}
	public class BooleanOrExpressionChildElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.BooleanOrExpressionChild");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanAndExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanAndExpressionChildParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//BooleanOrExpressionChild xmu2expression::BooleanOrExpressionChild:
		//	=> BooleanAndExpression
		//	| BooleanAndExpressionChild
		@Override public ParserRule getRule() { return rule; }
		
		//=> BooleanAndExpression | BooleanAndExpressionChild
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> BooleanAndExpression
		public RuleCall getBooleanAndExpressionParserRuleCall_0() { return cBooleanAndExpressionParserRuleCall_0; }
		
		//BooleanAndExpressionChild
		public RuleCall getBooleanAndExpressionChildParserRuleCall_1() { return cBooleanAndExpressionChildParserRuleCall_1; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Expression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBooleanOrExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cBooleanOrExpressionChildParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//Expression xmu2expression::Expression:
		//	=> BooleanOrExpression
		//	| BooleanOrExpressionChild
		@Override public ParserRule getRule() { return rule; }
		
		//=> BooleanOrExpression | BooleanOrExpressionChild
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//=> BooleanOrExpression
		public RuleCall getBooleanOrExpressionParserRuleCall_0() { return cBooleanOrExpressionParserRuleCall_0; }
		
		//BooleanOrExpressionChild
		public RuleCall getBooleanOrExpressionChildParserRuleCall_1() { return cBooleanOrExpressionChildParserRuleCall_1; }
	}
	public class BlockStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.BlockStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cBlockStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cBodyStatementParserRuleCall_2_0_0 = (RuleCall)cBodyAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cSemicolonKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cBodyAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cBodyStatementParserRuleCall_2_1_1_0 = (RuleCall)cBodyAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//// statement
		//BlockStatement xmu2statement::BlockStatement:
		//	{xmu2statement::BlockStatement} '{' (body+=Statement (';' body+=Statement)*)? '}'
		@Override public ParserRule getRule() { return rule; }
		
		//{xmu2statement::BlockStatement} '{' (body+=Statement (';' body+=Statement)*)? '}'
		public Group getGroup() { return cGroup; }
		
		//{xmu2statement::BlockStatement}
		public Action getBlockStatementAction_0() { return cBlockStatementAction_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//(body+=Statement (';' body+=Statement)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//body+=Statement
		public Assignment getBodyAssignment_2_0() { return cBodyAssignment_2_0; }
		
		//Statement
		public RuleCall getBodyStatementParserRuleCall_2_0_0() { return cBodyStatementParserRuleCall_2_0_0; }
		
		//(';' body+=Statement)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2_1_0() { return cSemicolonKeyword_2_1_0; }
		
		//body+=Statement
		public Assignment getBodyAssignment_2_1_1() { return cBodyAssignment_2_1_1; }
		
		//Statement
		public RuleCall getBodyStatementParserRuleCall_2_1_1_0() { return cBodyStatementParserRuleCall_2_1_1_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_3() { return cRightCurlyBracketKeyword_3; }
	}
	public class UpdateStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.UpdateStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cUpdateKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSourceAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSourcePatternParserRuleCall_1_0 = (RuleCall)cSourceAssignment_1.eContents().get(0);
		private final Keyword cWithKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cViewAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cViewPatternParserRuleCall_3_0 = (RuleCall)cViewAssignment_3.eContents().get(0);
		private final Keyword cByKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cClausesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cClausesUpdateClauseParserRuleCall_5_0 = (RuleCall)cClausesAssignment_5.eContents().get(0);
		
		//UpdateStatement xmu2statement::UpdateStatement:
		//	'update' source=Pattern 'with' view=Pattern 'by' clauses+=UpdateClause+
		@Override public ParserRule getRule() { return rule; }
		
		//'update' source=Pattern 'with' view=Pattern 'by' clauses+=UpdateClause+
		public Group getGroup() { return cGroup; }
		
		//'update'
		public Keyword getUpdateKeyword_0() { return cUpdateKeyword_0; }
		
		//source=Pattern
		public Assignment getSourceAssignment_1() { return cSourceAssignment_1; }
		
		//Pattern
		public RuleCall getSourcePatternParserRuleCall_1_0() { return cSourcePatternParserRuleCall_1_0; }
		
		//'with'
		public Keyword getWithKeyword_2() { return cWithKeyword_2; }
		
		//view=Pattern
		public Assignment getViewAssignment_3() { return cViewAssignment_3; }
		
		//Pattern
		public RuleCall getViewPatternParserRuleCall_3_0() { return cViewPatternParserRuleCall_3_0; }
		
		//'by'
		public Keyword getByKeyword_4() { return cByKeyword_4; }
		
		//clauses+=UpdateClause+
		public Assignment getClausesAssignment_5() { return cClausesAssignment_5; }
		
		//UpdateClause
		public RuleCall getClausesUpdateClauseParserRuleCall_5_0() { return cClausesUpdateClauseParserRuleCall_5_0; }
	}
	public class UpdateClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.UpdateClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTypeActionTypeEnumRuleCall_0_0 = (RuleCall)cTypeAssignment_0.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cStatementAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cStatementStatementParserRuleCall_2_0 = (RuleCall)cStatementAssignment_2.eContents().get(0);
		
		//UpdateClause xmu2statement::UpdateClause:
		//	type=ActionType '->' statement=Statement
		@Override public ParserRule getRule() { return rule; }
		
		//type=ActionType '->' statement=Statement
		public Group getGroup() { return cGroup; }
		
		//type=ActionType
		public Assignment getTypeAssignment_0() { return cTypeAssignment_0; }
		
		//ActionType
		public RuleCall getTypeActionTypeEnumRuleCall_0_0() { return cTypeActionTypeEnumRuleCall_0_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//statement=Statement
		public Assignment getStatementAssignment_2() { return cStatementAssignment_2; }
		
		//Statement
		public RuleCall getStatementStatementParserRuleCall_2_0() { return cStatementStatementParserRuleCall_2_0; }
	}
	public class SwitchStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.SwitchStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSwitchKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cRootAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRootVariableExpressionParserRuleCall_2_0 = (RuleCall)cRootAssignment_2.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Keyword cLeftCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		private final Assignment cCasesAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cCasesCaseClauseParserRuleCall_5_0 = (RuleCall)cCasesAssignment_5.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//SwitchStatement xmu2statement::SwitchStatement:
		//	'switch' '(' root=VariableExpression ')' '{' cases+=CaseClause+ '}'
		@Override public ParserRule getRule() { return rule; }
		
		//'switch' '(' root=VariableExpression ')' '{' cases+=CaseClause+ '}'
		public Group getGroup() { return cGroup; }
		
		//'switch'
		public Keyword getSwitchKeyword_0() { return cSwitchKeyword_0; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//root=VariableExpression
		public Assignment getRootAssignment_2() { return cRootAssignment_2; }
		
		//VariableExpression
		public RuleCall getRootVariableExpressionParserRuleCall_2_0() { return cRootVariableExpressionParserRuleCall_2_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_4() { return cLeftCurlyBracketKeyword_4; }
		
		//cases+=CaseClause+
		public Assignment getCasesAssignment_5() { return cCasesAssignment_5; }
		
		//CaseClause
		public RuleCall getCasesCaseClauseParserRuleCall_5_0() { return cCasesCaseClauseParserRuleCall_5_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_6() { return cRightCurlyBracketKeyword_6; }
	}
	public class CaseClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.CaseClause");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPatternCaseClauseParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExpressionCaseClauseParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cDefaultCaseClauseParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		//CaseClause xmu2statement::CaseClause:
		//	PatternCaseClause | ExpressionCaseClause | DefaultCaseClause
		@Override public ParserRule getRule() { return rule; }
		
		//PatternCaseClause | ExpressionCaseClause | DefaultCaseClause
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PatternCaseClause
		public RuleCall getPatternCaseClauseParserRuleCall_0() { return cPatternCaseClauseParserRuleCall_0; }
		
		//ExpressionCaseClause
		public RuleCall getExpressionCaseClauseParserRuleCall_1() { return cExpressionCaseClauseParserRuleCall_1; }
		
		//DefaultCaseClause
		public RuleCall getDefaultCaseClauseParserRuleCall_2() { return cDefaultCaseClauseParserRuleCall_2; }
	}
	public class PatternCaseClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.PatternCaseClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionPatternParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cActionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cActionStatementParserRuleCall_3_0 = (RuleCall)cActionAssignment_3.eContents().get(0);
		
		//PatternCaseClause xmu2statement::PatternCaseClause:
		//	'case' condition=Pattern '->' action=Statement
		@Override public ParserRule getRule() { return rule; }
		
		//'case' condition=Pattern '->' action=Statement
		public Group getGroup() { return cGroup; }
		
		//'case'
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//condition=Pattern
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//Pattern
		public RuleCall getConditionPatternParserRuleCall_1_0() { return cConditionPatternParserRuleCall_1_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_2() { return cHyphenMinusGreaterThanSignKeyword_2; }
		
		//action=Statement
		public Assignment getActionAssignment_3() { return cActionAssignment_3; }
		
		//Statement
		public RuleCall getActionStatementParserRuleCall_3_0() { return cActionStatementParserRuleCall_3_0; }
	}
	public class ExpressionCaseClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ExpressionCaseClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCaseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConditionAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConditionExpressionParserRuleCall_1_0 = (RuleCall)cConditionAssignment_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cActionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cActionStatementParserRuleCall_3_0 = (RuleCall)cActionAssignment_3.eContents().get(0);
		
		//ExpressionCaseClause xmu2statement::ExpressionCaseClause:
		//	'case' condition=Expression '->' action=Statement
		@Override public ParserRule getRule() { return rule; }
		
		//'case' condition=Expression '->' action=Statement
		public Group getGroup() { return cGroup; }
		
		//'case'
		public Keyword getCaseKeyword_0() { return cCaseKeyword_0; }
		
		//condition=Expression
		public Assignment getConditionAssignment_1() { return cConditionAssignment_1; }
		
		//Expression
		public RuleCall getConditionExpressionParserRuleCall_1_0() { return cConditionExpressionParserRuleCall_1_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_2() { return cHyphenMinusGreaterThanSignKeyword_2; }
		
		//action=Statement
		public Assignment getActionAssignment_3() { return cActionAssignment_3; }
		
		//Statement
		public RuleCall getActionStatementParserRuleCall_3_0() { return cActionStatementParserRuleCall_3_0; }
	}
	public class DefaultCaseClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.DefaultCaseClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOtherwiseKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cActionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cActionStatementParserRuleCall_2_0 = (RuleCall)cActionAssignment_2.eContents().get(0);
		
		//DefaultCaseClause xmu2statement::DefaultCaseClause:
		//	'otherwise' '->' action=Statement
		@Override public ParserRule getRule() { return rule; }
		
		//'otherwise' '->' action=Statement
		public Group getGroup() { return cGroup; }
		
		//'otherwise'
		public Keyword getOtherwiseKeyword_0() { return cOtherwiseKeyword_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_1() { return cHyphenMinusGreaterThanSignKeyword_1; }
		
		//action=Statement
		public Assignment getActionAssignment_2() { return cActionAssignment_2; }
		
		//Statement
		public RuleCall getActionStatementParserRuleCall_2_0() { return cActionStatementParserRuleCall_2_0; }
	}
	public class DeleteNodeStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.DeleteNodeStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDeleteKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cNodeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNodeVariableExpressionParserRuleCall_1_0 = (RuleCall)cNodeAssignment_1.eContents().get(0);
		
		//DeleteNodeStatement xmu2statement::DeleteNodeStatement:
		//	'delete' node=VariableExpression
		@Override public ParserRule getRule() { return rule; }
		
		//'delete' node=VariableExpression
		public Group getGroup() { return cGroup; }
		
		//'delete'
		public Keyword getDeleteKeyword_0() { return cDeleteKeyword_0; }
		
		//node=VariableExpression
		public Assignment getNodeAssignment_1() { return cNodeAssignment_1; }
		
		//VariableExpression
		public RuleCall getNodeVariableExpressionParserRuleCall_1_0() { return cNodeVariableExpressionParserRuleCall_1_0; }
	}
	public class DeleteLinkStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.DeleteLinkStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cConcreteDeleteLinkStatementAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cDeleteKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cSourceAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cSourceVariableExpressionParserRuleCall_2_0 = (RuleCall)cSourceAssignment_2.eContents().get(0);
		private final Keyword cFullStopKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFeatureAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFeatureNAMETerminalRuleCall_4_0 = (RuleCall)cFeatureAssignment_4.eContents().get(0);
		private final Keyword cEqualsSignKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cTargetAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cTargetExpressionParserRuleCall_6_0 = (RuleCall)cTargetAssignment_6.eContents().get(0);
		
		//DeleteLinkStatement xmu2statement::DeleteLinkStatement:
		//	{xmu2statement::ConcreteDeleteLinkStatement}
		//	//	'delete' source=VariableExpression '.' feature=NAME '=' target=MultiplicativeExpressionChild
		//	'delete' source=VariableExpression '.' feature=NAME '=' target=Expression
		@Override public ParserRule getRule() { return rule; }
		
		//{xmu2statement::ConcreteDeleteLinkStatement} //	'delete' source=VariableExpression '.' feature=NAME '=' target=MultiplicativeExpressionChild
		//'delete' source=VariableExpression '.' feature=NAME '=' target=Expression
		public Group getGroup() { return cGroup; }
		
		//{xmu2statement::ConcreteDeleteLinkStatement}
		public Action getConcreteDeleteLinkStatementAction_0() { return cConcreteDeleteLinkStatementAction_0; }
		
		////	'delete' source=VariableExpression '.' feature=NAME '=' target=MultiplicativeExpressionChild
		//'delete'
		public Keyword getDeleteKeyword_1() { return cDeleteKeyword_1; }
		
		//source=VariableExpression
		public Assignment getSourceAssignment_2() { return cSourceAssignment_2; }
		
		//VariableExpression
		public RuleCall getSourceVariableExpressionParserRuleCall_2_0() { return cSourceVariableExpressionParserRuleCall_2_0; }
		
		//'.'
		public Keyword getFullStopKeyword_3() { return cFullStopKeyword_3; }
		
		//feature=NAME
		public Assignment getFeatureAssignment_4() { return cFeatureAssignment_4; }
		
		//NAME
		public RuleCall getFeatureNAMETerminalRuleCall_4_0() { return cFeatureNAMETerminalRuleCall_4_0; }
		
		//'='
		public Keyword getEqualsSignKeyword_5() { return cEqualsSignKeyword_5; }
		
		//target=Expression
		public Assignment getTargetAssignment_6() { return cTargetAssignment_6; }
		
		//Expression
		public RuleCall getTargetExpressionParserRuleCall_6_0() { return cTargetExpressionParserRuleCall_6_0; }
	}
	public class EnforcePatternStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.EnforcePatternStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cEnforceKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPatternAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPatternPatternParserRuleCall_1_0 = (RuleCall)cPatternAssignment_1.eContents().get(0);
		
		//EnforcePatternStatement xmu2statement::EnforcePatternStatement:
		//	'enforce' pattern=Pattern
		@Override public ParserRule getRule() { return rule; }
		
		//'enforce' pattern=Pattern
		public Group getGroup() { return cGroup; }
		
		//'enforce'
		public Keyword getEnforceKeyword_0() { return cEnforceKeyword_0; }
		
		//pattern=Pattern
		public Assignment getPatternAssignment_1() { return cPatternAssignment_1; }
		
		//Pattern
		public RuleCall getPatternPatternParserRuleCall_1_0() { return cPatternPatternParserRuleCall_1_0; }
	}
	public class ForEachStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ForEachStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cForeachKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPatternAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPatternPatternParserRuleCall_1_0 = (RuleCall)cPatternAssignment_1.eContents().get(0);
		private final Keyword cHyphenMinusGreaterThanSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cActionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cActionStatementParserRuleCall_3_0 = (RuleCall)cActionAssignment_3.eContents().get(0);
		
		//ForEachStatement xmu2statement::ForEachStatement:
		//	'foreach' pattern=Pattern '->' action=Statement
		@Override public ParserRule getRule() { return rule; }
		
		//'foreach' pattern=Pattern '->' action=Statement
		public Group getGroup() { return cGroup; }
		
		//'foreach'
		public Keyword getForeachKeyword_0() { return cForeachKeyword_0; }
		
		//pattern=Pattern
		public Assignment getPatternAssignment_1() { return cPatternAssignment_1; }
		
		//Pattern
		public RuleCall getPatternPatternParserRuleCall_1_0() { return cPatternPatternParserRuleCall_1_0; }
		
		//'->'
		public Keyword getHyphenMinusGreaterThanSignKeyword_2() { return cHyphenMinusGreaterThanSignKeyword_2; }
		
		//action=Statement
		public Assignment getActionAssignment_3() { return cActionAssignment_3; }
		
		//Statement
		public RuleCall getActionStatementParserRuleCall_3_0() { return cActionStatementParserRuleCall_3_0; }
	}
	public class RuleCallStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.RuleCallStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRuleAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final CrossReference cRuleAbstractRuleCrossReference_0_0 = (CrossReference)cRuleAssignment_0.eContents().get(0);
		private final RuleCall cRuleAbstractRuleNAMETerminalRuleCall_0_0_1 = (RuleCall)cRuleAbstractRuleCrossReference_0_0.eContents().get(1);
		private final Keyword cLeftParenthesisKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Assignment cParametersAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cParametersExpressionParserRuleCall_2_0_0 = (RuleCall)cParametersAssignment_2_0.eContents().get(0);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Keyword cCommaKeyword_2_1_0 = (Keyword)cGroup_2_1.eContents().get(0);
		private final Assignment cParametersAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cParametersExpressionParserRuleCall_2_1_1_0 = (RuleCall)cParametersAssignment_2_1_1.eContents().get(0);
		private final Keyword cRightParenthesisKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//RuleCallStatement xmu2statement::RuleCallStatement:
		//	rule=[xmu2::AbstractRule|NAME] '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
		@Override public ParserRule getRule() { return rule; }
		
		//rule=[xmu2::AbstractRule|NAME] '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
		public Group getGroup() { return cGroup; }
		
		//rule=[xmu2::AbstractRule|NAME]
		public Assignment getRuleAssignment_0() { return cRuleAssignment_0; }
		
		//[xmu2::AbstractRule|NAME]
		public CrossReference getRuleAbstractRuleCrossReference_0_0() { return cRuleAbstractRuleCrossReference_0_0; }
		
		//NAME
		public RuleCall getRuleAbstractRuleNAMETerminalRuleCall_0_0_1() { return cRuleAbstractRuleNAMETerminalRuleCall_0_0_1; }
		
		//'('
		public Keyword getLeftParenthesisKeyword_1() { return cLeftParenthesisKeyword_1; }
		
		//(parameters+=Expression (',' parameters+=Expression)*)?
		public Group getGroup_2() { return cGroup_2; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_2_0() { return cParametersAssignment_2_0; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_2_0_0() { return cParametersExpressionParserRuleCall_2_0_0; }
		
		//(',' parameters+=Expression)*
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//','
		public Keyword getCommaKeyword_2_1_0() { return cCommaKeyword_2_1_0; }
		
		//parameters+=Expression
		public Assignment getParametersAssignment_2_1_1() { return cParametersAssignment_2_1_1; }
		
		//Expression
		public RuleCall getParametersExpressionParserRuleCall_2_1_1_0() { return cParametersExpressionParserRuleCall_2_1_1_0; }
		
		//')'
		public Keyword getRightParenthesisKeyword_3() { return cRightParenthesisKeyword_3; }
	}
	public class SkipElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Skip");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cSkipAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cSkipKeyword_1 = (Keyword)cGroup.eContents().get(1);
		
		//Skip xmu2statement::Skip:
		//	{xmu2statement::Skip} "skip"
		@Override public ParserRule getRule() { return rule; }
		
		//{xmu2statement::Skip} "skip"
		public Group getGroup() { return cGroup; }
		
		//{xmu2statement::Skip}
		public Action getSkipAction_0() { return cSkipAction_0; }
		
		//"skip"
		public Keyword getSkipKeyword_1() { return cSkipKeyword_1; }
	}
	public class FailElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Fail");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Action cFailAction_0 = (Action)cGroup.eContents().get(0);
		private final Keyword cFailKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExpressionExpressionParserRuleCall_2_0 = (RuleCall)cExpressionAssignment_2.eContents().get(0);
		
		//Fail xmu2statement::Fail:
		//	{xmu2statement::Fail} 'fail' expression=Expression?
		@Override public ParserRule getRule() { return rule; }
		
		//{xmu2statement::Fail} 'fail' expression=Expression?
		public Group getGroup() { return cGroup; }
		
		//{xmu2statement::Fail}
		public Action getFailAction_0() { return cFailAction_0; }
		
		//'fail'
		public Keyword getFailKeyword_1() { return cFailKeyword_1; }
		
		//expression=Expression?
		public Assignment getExpressionAssignment_2() { return cExpressionAssignment_2; }
		
		//Expression
		public RuleCall getExpressionExpressionParserRuleCall_2_0() { return cExpressionExpressionParserRuleCall_2_0; }
	}
	public class AssignStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.AssignStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cUpdatedVariableAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cUpdatedVariableVariableExpressionParserRuleCall_0_0 = (RuleCall)cUpdatedVariableAssignment_0.eContents().get(0);
		private final Keyword cColonColonEqualsSignKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cValueAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cValueExpressionParserRuleCall_2_0 = (RuleCall)cValueAssignment_2.eContents().get(0);
		
		//AssignStatement xmu2statement::AssignStatement:
		//	updatedVariable=VariableExpression '::=' value=Expression
		@Override public ParserRule getRule() { return rule; }
		
		//updatedVariable=VariableExpression '::=' value=Expression
		public Group getGroup() { return cGroup; }
		
		//updatedVariable=VariableExpression
		public Assignment getUpdatedVariableAssignment_0() { return cUpdatedVariableAssignment_0; }
		
		//VariableExpression
		public RuleCall getUpdatedVariableVariableExpressionParserRuleCall_0_0() { return cUpdatedVariableVariableExpressionParserRuleCall_0_0; }
		
		//'::='
		public Keyword getColonColonEqualsSignKeyword_1() { return cColonColonEqualsSignKeyword_1; }
		
		//value=Expression
		public Assignment getValueAssignment_2() { return cValueAssignment_2; }
		
		//Expression
		public RuleCall getValueExpressionParserRuleCall_2_0() { return cValueExpressionParserRuleCall_2_0; }
	}
	public class StatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Statement");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cBlockStatementParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUpdateStatementParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cSwitchStatementParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cDeleteNodeStatementParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cDeleteLinkStatementParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cEnforcePatternStatementParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		private final RuleCall cForEachStatementParserRuleCall_6 = (RuleCall)cAlternatives.eContents().get(6);
		private final RuleCall cRuleCallStatementParserRuleCall_7 = (RuleCall)cAlternatives.eContents().get(7);
		private final RuleCall cSkipParserRuleCall_8 = (RuleCall)cAlternatives.eContents().get(8);
		private final RuleCall cFailParserRuleCall_9 = (RuleCall)cAlternatives.eContents().get(9);
		private final RuleCall cAssignStatementParserRuleCall_10 = (RuleCall)cAlternatives.eContents().get(10);
		
		//Statement xmu2statement::Statement:
		//	BlockStatement | UpdateStatement | SwitchStatement
		//	| DeleteNodeStatement | DeleteLinkStatement | EnforcePatternStatement
		//	| ForEachStatement | RuleCallStatement
		//	| Skip | Fail | AssignStatement
		@Override public ParserRule getRule() { return rule; }
		
		//BlockStatement | UpdateStatement | SwitchStatement | DeleteNodeStatement | DeleteLinkStatement | EnforcePatternStatement
		//| ForEachStatement | RuleCallStatement | Skip | Fail | AssignStatement
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//BlockStatement
		public RuleCall getBlockStatementParserRuleCall_0() { return cBlockStatementParserRuleCall_0; }
		
		//UpdateStatement
		public RuleCall getUpdateStatementParserRuleCall_1() { return cUpdateStatementParserRuleCall_1; }
		
		//SwitchStatement
		public RuleCall getSwitchStatementParserRuleCall_2() { return cSwitchStatementParserRuleCall_2; }
		
		//DeleteNodeStatement
		public RuleCall getDeleteNodeStatementParserRuleCall_3() { return cDeleteNodeStatementParserRuleCall_3; }
		
		//DeleteLinkStatement
		public RuleCall getDeleteLinkStatementParserRuleCall_4() { return cDeleteLinkStatementParserRuleCall_4; }
		
		//EnforcePatternStatement
		public RuleCall getEnforcePatternStatementParserRuleCall_5() { return cEnforcePatternStatementParserRuleCall_5; }
		
		//ForEachStatement
		public RuleCall getForEachStatementParserRuleCall_6() { return cForEachStatementParserRuleCall_6; }
		
		//RuleCallStatement
		public RuleCall getRuleCallStatementParserRuleCall_7() { return cRuleCallStatementParserRuleCall_7; }
		
		//Skip
		public RuleCall getSkipParserRuleCall_8() { return cSkipParserRuleCall_8; }
		
		//Fail
		public RuleCall getFailParserRuleCall_9() { return cFailParserRuleCall_9; }
		
		//AssignStatement
		public RuleCall getAssignStatementParserRuleCall_10() { return cAssignStatementParserRuleCall_10; }
	}
	
	public class TagElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.Tag");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSourceEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSourceSourceKeyword_0_0 = (Keyword)cSourceEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cViewEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cViewViewKeyword_1_0 = (Keyword)cViewEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum Tag returns xmu2common::DomainTag:
		//	source | view;
		public EnumRule getRule() { return rule; }
		
		//source | view
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//source
		public EnumLiteralDeclaration getSourceEnumLiteralDeclaration_0() { return cSourceEnumLiteralDeclaration_0; }
		
		//'source'
		public Keyword getSourceSourceKeyword_0_0() { return cSourceSourceKeyword_0_0; }
		
		//view
		public EnumLiteralDeclaration getViewEnumLiteralDeclaration_1() { return cViewEnumLiteralDeclaration_1; }
		
		//'view'
		public Keyword getViewViewKeyword_1_0() { return cViewViewKeyword_1_0; }
	}
	public class LoopOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.LoopOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSelectEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSelectSelectKeyword_0_0 = (Keyword)cSelectEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cForAllEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cForAllForAllKeyword_1_0 = (Keyword)cForAllEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cExistsEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cExistsExistsKeyword_2_0 = (Keyword)cExistsEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum LoopOperator returns xmu2common::LoopOperator:
		//	select | forAll | exists;
		public EnumRule getRule() { return rule; }
		
		//select | forAll | exists
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//select
		public EnumLiteralDeclaration getSelectEnumLiteralDeclaration_0() { return cSelectEnumLiteralDeclaration_0; }
		
		//'select'
		public Keyword getSelectSelectKeyword_0_0() { return cSelectSelectKeyword_0_0; }
		
		//forAll
		public EnumLiteralDeclaration getForAllEnumLiteralDeclaration_1() { return cForAllEnumLiteralDeclaration_1; }
		
		//'forAll'
		public Keyword getForAllForAllKeyword_1_0() { return cForAllForAllKeyword_1_0; }
		
		//exists
		public EnumLiteralDeclaration getExistsEnumLiteralDeclaration_2() { return cExistsEnumLiteralDeclaration_2; }
		
		//'exists'
		public Keyword getExistsExistsKeyword_2_0() { return cExistsExistsKeyword_2_0; }
	}
	public class PositionOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.PositionOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cFirstEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cFirstFirstKeyword_0_0 = (Keyword)cFirstEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLastEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLastLastKeyword_1_0 = (Keyword)cLastEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cAtEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cAtAtKeyword_2_0 = (Keyword)cAtEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum PositionOperator returns xmu2common::PositionOperator:
		//	first | last | at;
		public EnumRule getRule() { return rule; }
		
		//first | last | at
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//first
		public EnumLiteralDeclaration getFirstEnumLiteralDeclaration_0() { return cFirstEnumLiteralDeclaration_0; }
		
		//'first'
		public Keyword getFirstFirstKeyword_0_0() { return cFirstFirstKeyword_0_0; }
		
		//last
		public EnumLiteralDeclaration getLastEnumLiteralDeclaration_1() { return cLastEnumLiteralDeclaration_1; }
		
		//'last'
		public Keyword getLastLastKeyword_1_0() { return cLastLastKeyword_1_0; }
		
		//at
		public EnumLiteralDeclaration getAtEnumLiteralDeclaration_2() { return cAtEnumLiteralDeclaration_2; }
		
		//'at'
		public Keyword getAtAtKeyword_2_0() { return cAtAtKeyword_2_0; }
	}
	public class EmptyValueElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.EmptyValue");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNullValueEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNullValueNullKeyword_0_0 = (Keyword)cNullValueEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cEmptyValueEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cEmptyValueUndefinedKeyword_1_0 = (Keyword)cEmptyValueEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum EmptyValue returns xmu2expression::EmptyValueType:
		//	nullValue='null' | emptyValue='undefined';
		public EnumRule getRule() { return rule; }
		
		//nullValue='null' | emptyValue='undefined'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//nullValue='null'
		public EnumLiteralDeclaration getNullValueEnumLiteralDeclaration_0() { return cNullValueEnumLiteralDeclaration_0; }
		
		//'null'
		public Keyword getNullValueNullKeyword_0_0() { return cNullValueNullKeyword_0_0; }
		
		//emptyValue='undefined'
		public EnumLiteralDeclaration getEmptyValueEnumLiteralDeclaration_1() { return cEmptyValueEnumLiteralDeclaration_1; }
		
		//'undefined'
		public Keyword getEmptyValueUndefinedKeyword_1_0() { return cEmptyValueUndefinedKeyword_1_0; }
	}
	public class UnaryOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.UnaryOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cNotEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cNotNotKeyword_0_0 = (Keyword)cNotEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cMinusEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cMinusHyphenMinusKeyword_1_0 = (Keyword)cMinusEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum UnaryOperator returns xmu2common::UnaryOperator:
		//	not | minus='-';
		public EnumRule getRule() { return rule; }
		
		//not | minus='-'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//not
		public EnumLiteralDeclaration getNotEnumLiteralDeclaration_0() { return cNotEnumLiteralDeclaration_0; }
		
		//'not'
		public Keyword getNotNotKeyword_0_0() { return cNotNotKeyword_0_0; }
		
		//minus='-'
		public EnumLiteralDeclaration getMinusEnumLiteralDeclaration_1() { return cMinusEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getMinusHyphenMinusKeyword_1_0() { return cMinusHyphenMinusKeyword_1_0; }
	}
	public class MultiplicativeOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.MultiplicativeOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMulEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMulAsteriskKeyword_0_0 = (Keyword)cMulEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cDivEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cDivSolidusKeyword_1_0 = (Keyword)cDivEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum MultiplicativeOperator returns xmu2common::MultiplicativeOperator:
		//	mul='*' | div='/';
		public EnumRule getRule() { return rule; }
		
		//mul='*' | div='/'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//mul='*'
		public EnumLiteralDeclaration getMulEnumLiteralDeclaration_0() { return cMulEnumLiteralDeclaration_0; }
		
		//'*'
		public Keyword getMulAsteriskKeyword_0_0() { return cMulAsteriskKeyword_0_0; }
		
		//div='/'
		public EnumLiteralDeclaration getDivEnumLiteralDeclaration_1() { return cDivEnumLiteralDeclaration_1; }
		
		//'/'
		public Keyword getDivSolidusKeyword_1_0() { return cDivSolidusKeyword_1_0; }
	}
	public class AdditiveOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.AdditiveOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cAddEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cAddPlusSignKeyword_0_0 = (Keyword)cAddEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSubEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSubHyphenMinusKeyword_1_0 = (Keyword)cSubEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cAppendEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cAppendPlusSignPlusSignKeyword_2_0 = (Keyword)cAppendEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum AdditiveOperator returns xmu2common::AdditiveOperator:
		//	add='+' | sub='-' | append='++';
		public EnumRule getRule() { return rule; }
		
		//add='+' | sub='-' | append='++'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//add='+'
		public EnumLiteralDeclaration getAddEnumLiteralDeclaration_0() { return cAddEnumLiteralDeclaration_0; }
		
		//'+'
		public Keyword getAddPlusSignKeyword_0_0() { return cAddPlusSignKeyword_0_0; }
		
		//sub='-'
		public EnumLiteralDeclaration getSubEnumLiteralDeclaration_1() { return cSubEnumLiteralDeclaration_1; }
		
		//'-'
		public Keyword getSubHyphenMinusKeyword_1_0() { return cSubHyphenMinusKeyword_1_0; }
		
		//append='++'
		public EnumLiteralDeclaration getAppendEnumLiteralDeclaration_2() { return cAppendEnumLiteralDeclaration_2; }
		
		//'++'
		public Keyword getAppendPlusSignPlusSignKeyword_2_0() { return cAppendPlusSignPlusSignKeyword_2_0; }
	}
	public class RelationalOperatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.RelationalOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cEqualEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cEqualEqualsSignKeyword_0_0 = (Keyword)cEqualEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cLessEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cLessLessThanSignKeyword_1_0 = (Keyword)cLessEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cLessEqualEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cLessEqualLessThanSignEqualsSignKeyword_2_0 = (Keyword)cLessEqualEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cGreaterEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cGreaterGreaterThanSignKeyword_3_0 = (Keyword)cGreaterEnumLiteralDeclaration_3.eContents().get(0);
		private final EnumLiteralDeclaration cGreaterEqualEnumLiteralDeclaration_4 = (EnumLiteralDeclaration)cAlternatives.eContents().get(4);
		private final Keyword cGreaterEqualGreaterThanSignEqualsSignKeyword_4_0 = (Keyword)cGreaterEqualEnumLiteralDeclaration_4.eContents().get(0);
		
		//enum RelationalOperator returns xmu2common::RelationalOperator:
		//	equal='=' | less='<' | lessEqual='<=' | greater='>' | greaterEqual='>=';
		public EnumRule getRule() { return rule; }
		
		//equal='=' | less='<' | lessEqual='<=' | greater='>' | greaterEqual='>='
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//equal='='
		public EnumLiteralDeclaration getEqualEnumLiteralDeclaration_0() { return cEqualEnumLiteralDeclaration_0; }
		
		//'='
		public Keyword getEqualEqualsSignKeyword_0_0() { return cEqualEqualsSignKeyword_0_0; }
		
		//less='<'
		public EnumLiteralDeclaration getLessEnumLiteralDeclaration_1() { return cLessEnumLiteralDeclaration_1; }
		
		//'<'
		public Keyword getLessLessThanSignKeyword_1_0() { return cLessLessThanSignKeyword_1_0; }
		
		//lessEqual='<='
		public EnumLiteralDeclaration getLessEqualEnumLiteralDeclaration_2() { return cLessEqualEnumLiteralDeclaration_2; }
		
		//'<='
		public Keyword getLessEqualLessThanSignEqualsSignKeyword_2_0() { return cLessEqualLessThanSignEqualsSignKeyword_2_0; }
		
		//greater='>'
		public EnumLiteralDeclaration getGreaterEnumLiteralDeclaration_3() { return cGreaterEnumLiteralDeclaration_3; }
		
		//'>'
		public Keyword getGreaterGreaterThanSignKeyword_3_0() { return cGreaterGreaterThanSignKeyword_3_0; }
		
		//greaterEqual='>='
		public EnumLiteralDeclaration getGreaterEqualEnumLiteralDeclaration_4() { return cGreaterEqualEnumLiteralDeclaration_4; }
		
		//'>='
		public Keyword getGreaterEqualGreaterThanSignEqualsSignKeyword_4_0() { return cGreaterEqualGreaterThanSignEqualsSignKeyword_4_0; }
	}
	public class ActionTypeElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ActionType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cMatchEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cMatchMatchKeyword_0_0 = (Keyword)cMatchEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cUnmatchsEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cUnmatchsUnmatchsKeyword_1_0 = (Keyword)cUnmatchsEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cUnmatchvEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cUnmatchvUnmatchvKeyword_2_0 = (Keyword)cUnmatchvEnumLiteralDeclaration_2.eContents().get(0);
		private final EnumLiteralDeclaration cDefaultEnumLiteralDeclaration_3 = (EnumLiteralDeclaration)cAlternatives.eContents().get(3);
		private final Keyword cDefaultDefaultKeyword_3_0 = (Keyword)cDefaultEnumLiteralDeclaration_3.eContents().get(0);
		
		//enum ActionType returns xmu2statement::ActionType:
		//	match | unmatchs | unmatchv | default;
		public EnumRule getRule() { return rule; }
		
		//match | unmatchs | unmatchv | default
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//match
		public EnumLiteralDeclaration getMatchEnumLiteralDeclaration_0() { return cMatchEnumLiteralDeclaration_0; }
		
		//'match'
		public Keyword getMatchMatchKeyword_0_0() { return cMatchMatchKeyword_0_0; }
		
		//unmatchs
		public EnumLiteralDeclaration getUnmatchsEnumLiteralDeclaration_1() { return cUnmatchsEnumLiteralDeclaration_1; }
		
		//'unmatchs'
		public Keyword getUnmatchsUnmatchsKeyword_1_0() { return cUnmatchsUnmatchsKeyword_1_0; }
		
		//unmatchv
		public EnumLiteralDeclaration getUnmatchvEnumLiteralDeclaration_2() { return cUnmatchvEnumLiteralDeclaration_2; }
		
		//'unmatchv'
		public Keyword getUnmatchvUnmatchvKeyword_2_0() { return cUnmatchvUnmatchvKeyword_2_0; }
		
		//default
		public EnumLiteralDeclaration getDefaultEnumLiteralDeclaration_3() { return cDefaultEnumLiteralDeclaration_3; }
		
		//'default'
		public Keyword getDefaultDefaultKeyword_3_0() { return cDefaultDefaultKeyword_3_0; }
	}
	
	private final TransformationModelElements pTransformationModel;
	private final EntryPointElements pEntryPoint;
	private final EntryDataElements pEntryData;
	private final TagElements eTag;
	private final AbstractRuleElements pAbstractRule;
	private final ModelRuleElements pModelRule;
	private final ArithmeticRuleElements pArithmeticRule;
	private final ParameterElements pParameter;
	private final TypeElements pType;
	private final ConcreteVariableDeclarationElements pConcreteVariableDeclaration;
	private final PatternElements pPattern;
	private final PatternNodeElements pPatternNode;
	private final PatternExpressionElements pPatternExpression;
	private final ObjectPatternExpressionElements pObjectPatternExpression;
	private final PropertyPatternExpressionElements pPropertyPatternExpression;
	private final ReflectiveVariableDeclarationElements pReflectiveVariableDeclaration;
	private final LoopPathElements pLoopPath;
	private final PositionPathElements pPositionPath;
	private final FeaturePathElements pFeaturePath;
	private final OperationPathElements pOperationPath;
	private final LoopOperatorElements eLoopOperator;
	private final PositionOperatorElements ePositionOperator;
	private final VariableExpressionElements pVariableExpression;
	private final PathElements pPath;
	private final EmptyExpressionElements pEmptyExpression;
	private final EmptyValueElements eEmptyValue;
	private final StringLiteralExpressionElements pStringLiteralExpression;
	private final IntegerLiteralExpressionElements pIntegerLiteralExpression;
	private final BooleanLiteralExpressionElements pBooleanLiteralExpression;
	private final EnumLiteralExpressionElements pEnumLiteralExpression;
	private final ObjectURIExpressionElements pObjectURIExpression;
	private final UnaryExpressionElements pUnaryExpression;
	private final UnaryOperatorElements eUnaryOperator;
	private final UnaryExpressionChildElements pUnaryExpressionChild;
	private final AtomicExpressionElements pAtomicExpression;
	private final ConstantExpressionElements pConstantExpression;
	private final MultiplicativeExpressionElements pMultiplicativeExpression;
	private final MultiplicativeOperatorElements eMultiplicativeOperator;
	private final MultiplicativeExpressionChildElements pMultiplicativeExpressionChild;
	private final AdditiveExpressionElements pAdditiveExpression;
	private final AdditiveOperatorElements eAdditiveOperator;
	private final AdditiveExpressionChildElements pAdditiveExpressionChild;
	private final RelationalExpressionElements pRelationalExpression;
	private final RelationalExpressionChildElements pRelationalExpressionChild;
	private final RelationalOperatorElements eRelationalOperator;
	private final BooleanAndExpressionElements pBooleanAndExpression;
	private final BooleanAndExpressionChildElements pBooleanAndExpressionChild;
	private final BooleanOrExpressionElements pBooleanOrExpression;
	private final BooleanOrExpressionChildElements pBooleanOrExpressionChild;
	private final ExpressionElements pExpression;
	private final BlockStatementElements pBlockStatement;
	private final UpdateStatementElements pUpdateStatement;
	private final UpdateClauseElements pUpdateClause;
	private final ActionTypeElements eActionType;
	private final SwitchStatementElements pSwitchStatement;
	private final CaseClauseElements pCaseClause;
	private final PatternCaseClauseElements pPatternCaseClause;
	private final ExpressionCaseClauseElements pExpressionCaseClause;
	private final DefaultCaseClauseElements pDefaultCaseClause;
	private final DeleteNodeStatementElements pDeleteNodeStatement;
	private final DeleteLinkStatementElements pDeleteLinkStatement;
	private final EnforcePatternStatementElements pEnforcePatternStatement;
	private final ForEachStatementElements pForEachStatement;
	private final RuleCallStatementElements pRuleCallStatement;
	private final SkipElements pSkip;
	private final FailElements pFail;
	private final AssignStatementElements pAssignStatement;
	private final StatementElements pStatement;
	private final TerminalRule tBOOLEAN;
	private final TerminalRule tINT;
	private final TerminalRule tSTRING;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tSL_COMMENT;
	private final TerminalRule tWS;
	private final TerminalRule tPRIMITIVE_TYPE;
	private final TerminalRule tPATH_NAME;
	private final TerminalRule tNAME;
	private final TerminalRule tMODEL_URI;
	private final TerminalRule tOBJ_URI;
	private final TerminalRule tID;
	
	private final Grammar grammar;

	@Inject
	public Xmu2GrammarAccess(GrammarProvider grammarProvider) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.pTransformationModel = new TransformationModelElements();
		this.pEntryPoint = new EntryPointElements();
		this.pEntryData = new EntryDataElements();
		this.eTag = new TagElements();
		this.pAbstractRule = new AbstractRuleElements();
		this.pModelRule = new ModelRuleElements();
		this.pArithmeticRule = new ArithmeticRuleElements();
		this.pParameter = new ParameterElements();
		this.pType = new TypeElements();
		this.pConcreteVariableDeclaration = new ConcreteVariableDeclarationElements();
		this.pPattern = new PatternElements();
		this.pPatternNode = new PatternNodeElements();
		this.pPatternExpression = new PatternExpressionElements();
		this.pObjectPatternExpression = new ObjectPatternExpressionElements();
		this.pPropertyPatternExpression = new PropertyPatternExpressionElements();
		this.pReflectiveVariableDeclaration = new ReflectiveVariableDeclarationElements();
		this.pLoopPath = new LoopPathElements();
		this.pPositionPath = new PositionPathElements();
		this.pFeaturePath = new FeaturePathElements();
		this.pOperationPath = new OperationPathElements();
		this.eLoopOperator = new LoopOperatorElements();
		this.ePositionOperator = new PositionOperatorElements();
		this.pVariableExpression = new VariableExpressionElements();
		this.pPath = new PathElements();
		this.pEmptyExpression = new EmptyExpressionElements();
		this.eEmptyValue = new EmptyValueElements();
		this.pStringLiteralExpression = new StringLiteralExpressionElements();
		this.pIntegerLiteralExpression = new IntegerLiteralExpressionElements();
		this.pBooleanLiteralExpression = new BooleanLiteralExpressionElements();
		this.pEnumLiteralExpression = new EnumLiteralExpressionElements();
		this.pObjectURIExpression = new ObjectURIExpressionElements();
		this.pUnaryExpression = new UnaryExpressionElements();
		this.eUnaryOperator = new UnaryOperatorElements();
		this.pUnaryExpressionChild = new UnaryExpressionChildElements();
		this.pAtomicExpression = new AtomicExpressionElements();
		this.pConstantExpression = new ConstantExpressionElements();
		this.pMultiplicativeExpression = new MultiplicativeExpressionElements();
		this.eMultiplicativeOperator = new MultiplicativeOperatorElements();
		this.pMultiplicativeExpressionChild = new MultiplicativeExpressionChildElements();
		this.pAdditiveExpression = new AdditiveExpressionElements();
		this.eAdditiveOperator = new AdditiveOperatorElements();
		this.pAdditiveExpressionChild = new AdditiveExpressionChildElements();
		this.pRelationalExpression = new RelationalExpressionElements();
		this.pRelationalExpressionChild = new RelationalExpressionChildElements();
		this.eRelationalOperator = new RelationalOperatorElements();
		this.pBooleanAndExpression = new BooleanAndExpressionElements();
		this.pBooleanAndExpressionChild = new BooleanAndExpressionChildElements();
		this.pBooleanOrExpression = new BooleanOrExpressionElements();
		this.pBooleanOrExpressionChild = new BooleanOrExpressionChildElements();
		this.pExpression = new ExpressionElements();
		this.pBlockStatement = new BlockStatementElements();
		this.pUpdateStatement = new UpdateStatementElements();
		this.pUpdateClause = new UpdateClauseElements();
		this.eActionType = new ActionTypeElements();
		this.pSwitchStatement = new SwitchStatementElements();
		this.pCaseClause = new CaseClauseElements();
		this.pPatternCaseClause = new PatternCaseClauseElements();
		this.pExpressionCaseClause = new ExpressionCaseClauseElements();
		this.pDefaultCaseClause = new DefaultCaseClauseElements();
		this.pDeleteNodeStatement = new DeleteNodeStatementElements();
		this.pDeleteLinkStatement = new DeleteLinkStatementElements();
		this.pEnforcePatternStatement = new EnforcePatternStatementElements();
		this.pForEachStatement = new ForEachStatementElements();
		this.pRuleCallStatement = new RuleCallStatementElements();
		this.pSkip = new SkipElements();
		this.pFail = new FailElements();
		this.pAssignStatement = new AssignStatementElements();
		this.pStatement = new StatementElements();
		this.tBOOLEAN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.BOOLEAN");
		this.tINT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.INT");
		this.tSTRING = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.STRING");
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ML_COMMENT");
		this.tSL_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.SL_COMMENT");
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.WS");
		this.tPRIMITIVE_TYPE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.PRIMITIVE_TYPE");
		this.tPATH_NAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.PATH_NAME");
		this.tNAME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.NAME");
		this.tMODEL_URI = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.MODEL_URI");
		this.tOBJ_URI = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.OBJ_URI");
		this.tID = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "edu.ustb.sei.mde.xmuxtext.Xmu2.ID");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("edu.ustb.sei.mde.xmuxtext.Xmu2".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	

	
	//TransformationModel xmu2::TransformationModel:
	//	{xmu2::TransformationModel}
	//	'module' name=NAME ('import' packages+=[ecore::EPackage|MODEL_URI])*
	//	entryPoints+=EntryPoint*
	//	rules+=AbstractRule*
	public TransformationModelElements getTransformationModelAccess() {
		return pTransformationModel;
	}
	
	public ParserRule getTransformationModelRule() {
		return getTransformationModelAccess().getRule();
	}
	
	//EntryPoint xmu2::EntryPoint:
	//	'entry' rule=[xmu2::ModelRule|NAME] '(' parameters+=EntryData ("," parameters+=EntryData)* ')'
	public EntryPointElements getEntryPointAccess() {
		return pEntryPoint;
	}
	
	public ParserRule getEntryPointRule() {
		return getEntryPointAccess().getRule();
	}
	
	//EntryData xmu2::EntryData:
	//	tag=Tag? '[' index=INT ^fragment=OBJ_URI? ']'
	public EntryDataElements getEntryDataAccess() {
		return pEntryData;
	}
	
	public ParserRule getEntryDataRule() {
		return getEntryDataAccess().getRule();
	}
	
	//enum Tag returns xmu2common::DomainTag:
	//	source | view;
	public TagElements getTagAccess() {
		return eTag;
	}
	
	public EnumRule getTagRule() {
		return getTagAccess().getRule();
	}
	
	//AbstractRule xmu2::AbstractRule:
	//	ArithmeticRule | ModelRule
	public AbstractRuleElements getAbstractRuleAccess() {
		return pAbstractRule;
	}
	
	public ParserRule getAbstractRuleRule() {
		return getAbstractRuleAccess().getRule();
	}
	
	//ModelRule xmu2::ModelRule:
	//	'rule' name=NAME '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '{'
	//	(variableDeclarations+=ConcreteVariableDeclaration ';')*
	//	statement=Statement?
	//	'}'
	public ModelRuleElements getModelRuleAccess() {
		return pModelRule;
	}
	
	public ParserRule getModelRuleRule() {
		return getModelRuleAccess().getRule();
	}
	
	//ArithmeticRule xmu2::ArithmeticRule:
	//	'function' name=NAME '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '{'
	//	statements+=Statement*
	//	'}'
	public ArithmeticRuleElements getArithmeticRuleAccess() {
		return pArithmeticRule;
	}
	
	public ParserRule getArithmeticRuleRule() {
		return getArithmeticRuleAccess().getRule();
	}
	
	//Parameter xmu2::Parameter:
	//	tag=Tag? name=NAME ':' type=[ecore::EClassifier|Type]
	public ParameterElements getParameterAccess() {
		return pParameter;
	}
	
	public ParserRule getParameterRule() {
		return getParameterAccess().getRule();
	}
	
	//Type:
	//	PRIMITIVE_TYPE | PATH_NAME;
	public TypeElements getTypeAccess() {
		return pType;
	}
	
	public ParserRule getTypeRule() {
		return getTypeAccess().getRule();
	}
	
	//ConcreteVariableDeclaration xmu2::ConcreteVariableDeclaration:
	//	name=NAME ':' type=[ecore::EClassifier|Type]
	public ConcreteVariableDeclarationElements getConcreteVariableDeclarationAccess() {
		return pConcreteVariableDeclaration;
	}
	
	public ParserRule getConcreteVariableDeclarationRule() {
		return getConcreteVariableDeclarationAccess().getRule();
	}
	
	//// pattern
	//Pattern xmu2pattern::Pattern:
	//	root=PatternNode ('[' guard=Expression ']')?
	public PatternElements getPatternAccess() {
		return pPattern;
	}
	
	public ParserRule getPatternRule() {
		return getPatternAccess().getRule();
	}
	
	//PatternNode xmu2pattern::PatternNode:
	//	{xmu2pattern::PatternNode} variable=ConcreteVariableDeclaration ('{' (expressions+=PatternExpression (','
	//	expressions+=PatternExpression)*)? '}')?
	public PatternNodeElements getPatternNodeAccess() {
		return pPatternNode;
	}
	
	public ParserRule getPatternNodeRule() {
		return getPatternNodeAccess().getRule();
	}
	
	//PatternExpression xmu2pattern::PatternExpression:
	//	=> PropertyPatternExpression
	//	| ObjectPatternExpression
	public PatternExpressionElements getPatternExpressionAccess() {
		return pPatternExpression;
	}
	
	public ParserRule getPatternExpressionRule() {
		return getPatternExpressionAccess().getRule();
	}
	
	//ObjectPatternExpression xmu2pattern::ObjectPatternExpression:
	//	{xmu2pattern::ObjectPatternExpression} feature=[ecore::EStructuralFeature|NAME] selector=LoopPath?
	//	position=PositionPath? '=' nullable?='?'? targetNode=PatternNode
	public ObjectPatternExpressionElements getObjectPatternExpressionAccess() {
		return pObjectPatternExpression;
	}
	
	public ParserRule getObjectPatternExpressionRule() {
		return getObjectPatternExpressionAccess().getRule();
	}
	
	//PropertyPatternExpression xmu2pattern::PropertyPatternExpression:
	//	{xmu2pattern::PropertyPatternExpression} feature=[ecore::EStructuralFeature|NAME] selector=LoopPath?
	//	position=PositionPath? '=' nullable?='?'? targetExpression=Expression
	public PropertyPatternExpressionElements getPropertyPatternExpressionAccess() {
		return pPropertyPatternExpression;
	}
	
	public ParserRule getPropertyPatternExpressionRule() {
		return getPropertyPatternExpressionAccess().getRule();
	}
	
	//ReflectiveVariableDeclaration xmu2::ReflectiveVariableDeclaration:
	//	name=NAME
	public ReflectiveVariableDeclarationElements getReflectiveVariableDeclarationAccess() {
		return pReflectiveVariableDeclaration;
	}
	
	public ParserRule getReflectiveVariableDeclarationRule() {
		return getReflectiveVariableDeclarationAccess().getRule();
	}
	
	//// path
	//LoopPath xmu2expression::LoopPath:
	//	'->' operator=LoopOperator '(' variable=ConcreteVariableDeclaration '|' body=Expression ')'
	public LoopPathElements getLoopPathAccess() {
		return pLoopPath;
	}
	
	public ParserRule getLoopPathRule() {
		return getLoopPathAccess().getRule();
	}
	
	//PositionPath xmu2expression::PositionPath:
	//	'->' type=PositionOperator '(' value=Expression? ')'
	public PositionPathElements getPositionPathAccess() {
		return pPositionPath;
	}
	
	public ParserRule getPositionPathRule() {
		return getPositionPathAccess().getRule();
	}
	
	//FeaturePath xmu2expression::FeaturePath:
	//	'.' feature=NAME
	public FeaturePathElements getFeaturePathAccess() {
		return pFeaturePath;
	}
	
	public ParserRule getFeaturePathRule() {
		return getFeaturePathAccess().getRule();
	}
	
	//OperationPath xmu2expression::OperationPath:
	//	'.' operation=NAME '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
	public OperationPathElements getOperationPathAccess() {
		return pOperationPath;
	}
	
	public ParserRule getOperationPathRule() {
		return getOperationPathAccess().getRule();
	}
	
	//enum LoopOperator returns xmu2common::LoopOperator:
	//	select | forAll | exists;
	public LoopOperatorElements getLoopOperatorAccess() {
		return eLoopOperator;
	}
	
	public EnumRule getLoopOperatorRule() {
		return getLoopOperatorAccess().getRule();
	}
	
	//enum PositionOperator returns xmu2common::PositionOperator:
	//	first | last | at;
	public PositionOperatorElements getPositionOperatorAccess() {
		return ePositionOperator;
	}
	
	public EnumRule getPositionOperatorRule() {
		return getPositionOperatorAccess().getRule();
	}
	
	//// expression
	//VariableExpression xmu2expression::VariableExpression:
	//	variable=NAME
	public VariableExpressionElements getVariableExpressionAccess() {
		return pVariableExpression;
	}
	
	public ParserRule getVariableExpressionRule() {
		return getVariableExpressionAccess().getRule();
	}
	
	////PathExpression returns xmu2expression::PathExpression :
	////	host = AtomicExpression (path+=Path)+
	////;
	//Path xmu2expression::Path:
	//	=> LoopPath
	//	| PositionPath
	//	| => FeaturePath
	//	| OperationPath
	public PathElements getPathAccess() {
		return pPath;
	}
	
	public ParserRule getPathRule() {
		return getPathAccess().getRule();
	}
	
	//EmptyExpression xmu2expression::EmptyExpression:
	//	type=EmptyValue
	public EmptyExpressionElements getEmptyExpressionAccess() {
		return pEmptyExpression;
	}
	
	public ParserRule getEmptyExpressionRule() {
		return getEmptyExpressionAccess().getRule();
	}
	
	//enum EmptyValue returns xmu2expression::EmptyValueType:
	//	nullValue='null' | emptyValue='undefined';
	public EmptyValueElements getEmptyValueAccess() {
		return eEmptyValue;
	}
	
	public EnumRule getEmptyValueRule() {
		return getEmptyValueAccess().getRule();
	}
	
	//StringLiteralExpression xmu2expression::StringLiteralExpression:
	//	value=STRING
	public StringLiteralExpressionElements getStringLiteralExpressionAccess() {
		return pStringLiteralExpression;
	}
	
	public ParserRule getStringLiteralExpressionRule() {
		return getStringLiteralExpressionAccess().getRule();
	}
	
	//IntegerLiteralExpression xmu2expression::IntegerLiteralExpression:
	//	value=INT
	public IntegerLiteralExpressionElements getIntegerLiteralExpressionAccess() {
		return pIntegerLiteralExpression;
	}
	
	public ParserRule getIntegerLiteralExpressionRule() {
		return getIntegerLiteralExpressionAccess().getRule();
	}
	
	//BooleanLiteralExpression xmu2expression::BooleanLiteralExpression:
	//	value=BOOLEAN
	public BooleanLiteralExpressionElements getBooleanLiteralExpressionAccess() {
		return pBooleanLiteralExpression;
	}
	
	public ParserRule getBooleanLiteralExpressionRule() {
		return getBooleanLiteralExpressionAccess().getRule();
	}
	
	//EnumLiteralExpression xmu2expression::EnumLiteralExpression:
	//	type=[ecore::EEnum|Type] '::' value=[ecore::EEnumLiteral|NAME]
	public EnumLiteralExpressionElements getEnumLiteralExpressionAccess() {
		return pEnumLiteralExpression;
	}
	
	public ParserRule getEnumLiteralExpressionRule() {
		return getEnumLiteralExpressionAccess().getRule();
	}
	
	//ObjectURIExpression xmu2expression::ObjectURIExpression:
	//	object=[ecore::EObject|OBJ_URI]
	public ObjectURIExpressionElements getObjectURIExpressionAccess() {
		return pObjectURIExpression;
	}
	
	public ParserRule getObjectURIExpressionRule() {
		return getObjectURIExpressionAccess().getRule();
	}
	
	//UnaryExpression xmu2expression::UnaryExpression:
	//	operator=UnaryOperator body=UnaryExpressionChild
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return pUnaryExpression;
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}
	
	//enum UnaryOperator returns xmu2common::UnaryOperator:
	//	not | minus='-';
	public UnaryOperatorElements getUnaryOperatorAccess() {
		return eUnaryOperator;
	}
	
	public EnumRule getUnaryOperatorRule() {
		return getUnaryOperatorAccess().getRule();
	}
	
	//UnaryExpressionChild xmu2expression::UnaryExpressionChild:
	//	AtomicExpression ({xmu2expression::PathExpression.host=current} path+=Path path+=Path*)?
	public UnaryExpressionChildElements getUnaryExpressionChildAccess() {
		return pUnaryExpressionChild;
	}
	
	public ParserRule getUnaryExpressionChildRule() {
		return getUnaryExpressionChildAccess().getRule();
	}
	
	//AtomicExpression xmu2expression::AtomicExpression:
	//	'(' {xmu2expression::ParenExpression} body=Expression ')'
	//	| VariableExpression | ConstantExpression
	public AtomicExpressionElements getAtomicExpressionAccess() {
		return pAtomicExpression;
	}
	
	public ParserRule getAtomicExpressionRule() {
		return getAtomicExpressionAccess().getRule();
	}
	
	//ConstantExpression xmu2expression::ConstantExpression:
	//	EmptyExpression | StringLiteralExpression
	//	| IntegerLiteralExpression | BooleanLiteralExpression
	//	| EnumLiteralExpression | ObjectURIExpression
	public ConstantExpressionElements getConstantExpressionAccess() {
		return pConstantExpression;
	}
	
	public ParserRule getConstantExpressionRule() {
		return getConstantExpressionAccess().getRule();
	}
	
	//MultiplicativeExpression xmu2expression::MultiplicativeExpression:
	//	operands+=MultiplicativeExpressionChild (operators+=MultiplicativeOperator operands+=MultiplicativeExpressionChild)+
	public MultiplicativeExpressionElements getMultiplicativeExpressionAccess() {
		return pMultiplicativeExpression;
	}
	
	public ParserRule getMultiplicativeExpressionRule() {
		return getMultiplicativeExpressionAccess().getRule();
	}
	
	//enum MultiplicativeOperator returns xmu2common::MultiplicativeOperator:
	//	mul='*' | div='/';
	public MultiplicativeOperatorElements getMultiplicativeOperatorAccess() {
		return eMultiplicativeOperator;
	}
	
	public EnumRule getMultiplicativeOperatorRule() {
		return getMultiplicativeOperatorAccess().getRule();
	}
	
	//MultiplicativeExpressionChild xmu2expression::MultiplicativeExpressionChild:
	//	=> UnaryExpression
	//	| UnaryExpressionChild
	public MultiplicativeExpressionChildElements getMultiplicativeExpressionChildAccess() {
		return pMultiplicativeExpressionChild;
	}
	
	public ParserRule getMultiplicativeExpressionChildRule() {
		return getMultiplicativeExpressionChildAccess().getRule();
	}
	
	//AdditiveExpression xmu2expression::AdditiveExpression:
	//	operands+=AdditiveExpressionChild (operators+=AdditiveOperator operands+=AdditiveExpressionChild)+
	public AdditiveExpressionElements getAdditiveExpressionAccess() {
		return pAdditiveExpression;
	}
	
	public ParserRule getAdditiveExpressionRule() {
		return getAdditiveExpressionAccess().getRule();
	}
	
	//enum AdditiveOperator returns xmu2common::AdditiveOperator:
	//	add='+' | sub='-' | append='++';
	public AdditiveOperatorElements getAdditiveOperatorAccess() {
		return eAdditiveOperator;
	}
	
	public EnumRule getAdditiveOperatorRule() {
		return getAdditiveOperatorAccess().getRule();
	}
	
	//AdditiveExpressionChild xmu2expression::AdditiveExpressionChild:
	//	=> MultiplicativeExpression
	//	| MultiplicativeExpressionChild
	public AdditiveExpressionChildElements getAdditiveExpressionChildAccess() {
		return pAdditiveExpressionChild;
	}
	
	public ParserRule getAdditiveExpressionChildRule() {
		return getAdditiveExpressionChildAccess().getRule();
	}
	
	//RelationalExpression xmu2expression::RelationalExpression:
	//	left=RelationalExpressionChild operator=RelationalOperator right=RelationalExpressionChild
	public RelationalExpressionElements getRelationalExpressionAccess() {
		return pRelationalExpression;
	}
	
	public ParserRule getRelationalExpressionRule() {
		return getRelationalExpressionAccess().getRule();
	}
	
	//RelationalExpressionChild xmu2expression::RelationalExpressionChild:
	//	=> AdditiveExpression
	//	| AdditiveExpressionChild
	public RelationalExpressionChildElements getRelationalExpressionChildAccess() {
		return pRelationalExpressionChild;
	}
	
	public ParserRule getRelationalExpressionChildRule() {
		return getRelationalExpressionChildAccess().getRule();
	}
	
	//enum RelationalOperator returns xmu2common::RelationalOperator:
	//	equal='=' | less='<' | lessEqual='<=' | greater='>' | greaterEqual='>=';
	public RelationalOperatorElements getRelationalOperatorAccess() {
		return eRelationalOperator;
	}
	
	public EnumRule getRelationalOperatorRule() {
		return getRelationalOperatorAccess().getRule();
	}
	
	//BooleanAndExpression xmu2expression::BooleanAndExpression:
	//	operands+=BooleanAndExpressionChild ('and' operands+=BooleanAndExpressionChild)+
	public BooleanAndExpressionElements getBooleanAndExpressionAccess() {
		return pBooleanAndExpression;
	}
	
	public ParserRule getBooleanAndExpressionRule() {
		return getBooleanAndExpressionAccess().getRule();
	}
	
	//BooleanAndExpressionChild xmu2expression::BooleanAndExpressionChild:
	//	=> RelationalExpression
	//	| RelationalExpressionChild
	public BooleanAndExpressionChildElements getBooleanAndExpressionChildAccess() {
		return pBooleanAndExpressionChild;
	}
	
	public ParserRule getBooleanAndExpressionChildRule() {
		return getBooleanAndExpressionChildAccess().getRule();
	}
	
	//BooleanOrExpression xmu2expression::BooleanOrExpression:
	//	operands+=BooleanOrExpressionChild ('or' operands+=BooleanOrExpressionChild)+
	public BooleanOrExpressionElements getBooleanOrExpressionAccess() {
		return pBooleanOrExpression;
	}
	
	public ParserRule getBooleanOrExpressionRule() {
		return getBooleanOrExpressionAccess().getRule();
	}
	
	//BooleanOrExpressionChild xmu2expression::BooleanOrExpressionChild:
	//	=> BooleanAndExpression
	//	| BooleanAndExpressionChild
	public BooleanOrExpressionChildElements getBooleanOrExpressionChildAccess() {
		return pBooleanOrExpressionChild;
	}
	
	public ParserRule getBooleanOrExpressionChildRule() {
		return getBooleanOrExpressionChildAccess().getRule();
	}
	
	//Expression xmu2expression::Expression:
	//	=> BooleanOrExpression
	//	| BooleanOrExpressionChild
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//// statement
	//BlockStatement xmu2statement::BlockStatement:
	//	{xmu2statement::BlockStatement} '{' (body+=Statement (';' body+=Statement)*)? '}'
	public BlockStatementElements getBlockStatementAccess() {
		return pBlockStatement;
	}
	
	public ParserRule getBlockStatementRule() {
		return getBlockStatementAccess().getRule();
	}
	
	//UpdateStatement xmu2statement::UpdateStatement:
	//	'update' source=Pattern 'with' view=Pattern 'by' clauses+=UpdateClause+
	public UpdateStatementElements getUpdateStatementAccess() {
		return pUpdateStatement;
	}
	
	public ParserRule getUpdateStatementRule() {
		return getUpdateStatementAccess().getRule();
	}
	
	//UpdateClause xmu2statement::UpdateClause:
	//	type=ActionType '->' statement=Statement
	public UpdateClauseElements getUpdateClauseAccess() {
		return pUpdateClause;
	}
	
	public ParserRule getUpdateClauseRule() {
		return getUpdateClauseAccess().getRule();
	}
	
	//enum ActionType returns xmu2statement::ActionType:
	//	match | unmatchs | unmatchv | default;
	public ActionTypeElements getActionTypeAccess() {
		return eActionType;
	}
	
	public EnumRule getActionTypeRule() {
		return getActionTypeAccess().getRule();
	}
	
	//SwitchStatement xmu2statement::SwitchStatement:
	//	'switch' '(' root=VariableExpression ')' '{' cases+=CaseClause+ '}'
	public SwitchStatementElements getSwitchStatementAccess() {
		return pSwitchStatement;
	}
	
	public ParserRule getSwitchStatementRule() {
		return getSwitchStatementAccess().getRule();
	}
	
	//CaseClause xmu2statement::CaseClause:
	//	PatternCaseClause | ExpressionCaseClause | DefaultCaseClause
	public CaseClauseElements getCaseClauseAccess() {
		return pCaseClause;
	}
	
	public ParserRule getCaseClauseRule() {
		return getCaseClauseAccess().getRule();
	}
	
	//PatternCaseClause xmu2statement::PatternCaseClause:
	//	'case' condition=Pattern '->' action=Statement
	public PatternCaseClauseElements getPatternCaseClauseAccess() {
		return pPatternCaseClause;
	}
	
	public ParserRule getPatternCaseClauseRule() {
		return getPatternCaseClauseAccess().getRule();
	}
	
	//ExpressionCaseClause xmu2statement::ExpressionCaseClause:
	//	'case' condition=Expression '->' action=Statement
	public ExpressionCaseClauseElements getExpressionCaseClauseAccess() {
		return pExpressionCaseClause;
	}
	
	public ParserRule getExpressionCaseClauseRule() {
		return getExpressionCaseClauseAccess().getRule();
	}
	
	//DefaultCaseClause xmu2statement::DefaultCaseClause:
	//	'otherwise' '->' action=Statement
	public DefaultCaseClauseElements getDefaultCaseClauseAccess() {
		return pDefaultCaseClause;
	}
	
	public ParserRule getDefaultCaseClauseRule() {
		return getDefaultCaseClauseAccess().getRule();
	}
	
	//DeleteNodeStatement xmu2statement::DeleteNodeStatement:
	//	'delete' node=VariableExpression
	public DeleteNodeStatementElements getDeleteNodeStatementAccess() {
		return pDeleteNodeStatement;
	}
	
	public ParserRule getDeleteNodeStatementRule() {
		return getDeleteNodeStatementAccess().getRule();
	}
	
	//DeleteLinkStatement xmu2statement::DeleteLinkStatement:
	//	{xmu2statement::ConcreteDeleteLinkStatement}
	//	//	'delete' source=VariableExpression '.' feature=NAME '=' target=MultiplicativeExpressionChild
	//	'delete' source=VariableExpression '.' feature=NAME '=' target=Expression
	public DeleteLinkStatementElements getDeleteLinkStatementAccess() {
		return pDeleteLinkStatement;
	}
	
	public ParserRule getDeleteLinkStatementRule() {
		return getDeleteLinkStatementAccess().getRule();
	}
	
	//EnforcePatternStatement xmu2statement::EnforcePatternStatement:
	//	'enforce' pattern=Pattern
	public EnforcePatternStatementElements getEnforcePatternStatementAccess() {
		return pEnforcePatternStatement;
	}
	
	public ParserRule getEnforcePatternStatementRule() {
		return getEnforcePatternStatementAccess().getRule();
	}
	
	//ForEachStatement xmu2statement::ForEachStatement:
	//	'foreach' pattern=Pattern '->' action=Statement
	public ForEachStatementElements getForEachStatementAccess() {
		return pForEachStatement;
	}
	
	public ParserRule getForEachStatementRule() {
		return getForEachStatementAccess().getRule();
	}
	
	//RuleCallStatement xmu2statement::RuleCallStatement:
	//	rule=[xmu2::AbstractRule|NAME] '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
	public RuleCallStatementElements getRuleCallStatementAccess() {
		return pRuleCallStatement;
	}
	
	public ParserRule getRuleCallStatementRule() {
		return getRuleCallStatementAccess().getRule();
	}
	
	//Skip xmu2statement::Skip:
	//	{xmu2statement::Skip} "skip"
	public SkipElements getSkipAccess() {
		return pSkip;
	}
	
	public ParserRule getSkipRule() {
		return getSkipAccess().getRule();
	}
	
	//Fail xmu2statement::Fail:
	//	{xmu2statement::Fail} 'fail' expression=Expression?
	public FailElements getFailAccess() {
		return pFail;
	}
	
	public ParserRule getFailRule() {
		return getFailAccess().getRule();
	}
	
	//AssignStatement xmu2statement::AssignStatement:
	//	updatedVariable=VariableExpression '::=' value=Expression
	public AssignStatementElements getAssignStatementAccess() {
		return pAssignStatement;
	}
	
	public ParserRule getAssignStatementRule() {
		return getAssignStatementAccess().getRule();
	}
	
	//Statement xmu2statement::Statement:
	//	BlockStatement | UpdateStatement | SwitchStatement
	//	| DeleteNodeStatement | DeleteLinkStatement | EnforcePatternStatement
	//	| ForEachStatement | RuleCallStatement
	//	| Skip | Fail | AssignStatement
	public StatementElements getStatementAccess() {
		return pStatement;
	}
	
	public ParserRule getStatementRule() {
		return getStatementAccess().getRule();
	}
	
	//terminal BOOLEAN returns ecore::EBoolean:
	//	'true' | 'false';
	public TerminalRule getBOOLEANRule() {
		return tBOOLEAN;
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return tINT;
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return tSTRING;
	}
	
	//terminal ML_COMMENT:
	//	'/ *'->'* /';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return tSL_COMMENT;
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//terminal PRIMITIVE_TYPE:
	//	'String' | 'Boolean' | 'Integer' | 'OclAny' | 'Resource' | 'OclObject';
	public TerminalRule getPRIMITIVE_TYPERule() {
		return tPRIMITIVE_TYPE;
	}
	
	//terminal PATH_NAME:
	//	ID '!' ID;
	public TerminalRule getPATH_NAMERule() {
		return tPATH_NAME;
	}
	
	//terminal NAME:
	//	ID '@post'?;
	public TerminalRule getNAMERule() {
		return tNAME;
	}
	
	//terminal MODEL_URI:
	//	'<'->'>';
	public TerminalRule getMODEL_URIRule() {
		return tMODEL_URI;
	}
	
	//terminal OBJ_URI:
	//	'@' ('a'..'z' | 'A'..'Z' | '0'..'9' | '_' | '/' | '\\' | '.' | ':' | '#')*;
	public TerminalRule getOBJ_URIRule() {
		return tOBJ_URI;
	}
	
	//terminal fragment ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return tID;
	}
}
