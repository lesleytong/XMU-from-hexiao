/*
 * generated by Xtext 2.10.0
 */
package edu.ustb.sei.mde.xmuxtext.serializer;

import com.google.inject.Inject;
import edu.ustb.sei.mde.xmu2.ArithmeticRule;
import edu.ustb.sei.mde.xmu2.ConcreteVariableDeclaration;
import edu.ustb.sei.mde.xmu2.EntryData;
import edu.ustb.sei.mde.xmu2.EntryPoint;
import edu.ustb.sei.mde.xmu2.ModelRule;
import edu.ustb.sei.mde.xmu2.ReflectiveVariableDeclaration;
import edu.ustb.sei.mde.xmu2.TransformationModel;
import edu.ustb.sei.mde.xmu2.Xmu2Package;
import edu.ustb.sei.mde.xmu2.expression.AdditiveExpression;
import edu.ustb.sei.mde.xmu2.expression.BooleanAndExpression;
import edu.ustb.sei.mde.xmu2.expression.BooleanLiteralExpression;
import edu.ustb.sei.mde.xmu2.expression.BooleanOrExpression;
import edu.ustb.sei.mde.xmu2.expression.EmptyExpression;
import edu.ustb.sei.mde.xmu2.expression.EnumLiteralExpression;
import edu.ustb.sei.mde.xmu2.expression.ExpressionPackage;
import edu.ustb.sei.mde.xmu2.expression.FeaturePath;
import edu.ustb.sei.mde.xmu2.expression.IntegerLiteralExpression;
import edu.ustb.sei.mde.xmu2.expression.LoopPath;
import edu.ustb.sei.mde.xmu2.expression.MultiplicativeExpression;
import edu.ustb.sei.mde.xmu2.expression.ObjectURIExpression;
import edu.ustb.sei.mde.xmu2.expression.OperationPath;
import edu.ustb.sei.mde.xmu2.expression.ParenExpression;
import edu.ustb.sei.mde.xmu2.expression.PathExpression;
import edu.ustb.sei.mde.xmu2.expression.PositionPath;
import edu.ustb.sei.mde.xmu2.expression.RelationalExpression;
import edu.ustb.sei.mde.xmu2.expression.StringLiteralExpression;
import edu.ustb.sei.mde.xmu2.expression.UnaryExpression;
import edu.ustb.sei.mde.xmu2.expression.VariableExpression;
import edu.ustb.sei.mde.xmu2.pattern.ObjectPatternExpression;
import edu.ustb.sei.mde.xmu2.pattern.Pattern;
import edu.ustb.sei.mde.xmu2.pattern.PatternNode;
import edu.ustb.sei.mde.xmu2.pattern.PatternPackage;
import edu.ustb.sei.mde.xmu2.pattern.PropertyPatternExpression;
import edu.ustb.sei.mde.xmu2.statement.AssignStatement;
import edu.ustb.sei.mde.xmu2.statement.BlockStatement;
import edu.ustb.sei.mde.xmu2.statement.ConcreteDeleteLinkStatement;
import edu.ustb.sei.mde.xmu2.statement.DefaultCaseClause;
import edu.ustb.sei.mde.xmu2.statement.DeleteNodeStatement;
import edu.ustb.sei.mde.xmu2.statement.EnforcePatternStatement;
import edu.ustb.sei.mde.xmu2.statement.ExpressionCaseClause;
import edu.ustb.sei.mde.xmu2.statement.Fail;
import edu.ustb.sei.mde.xmu2.statement.ForEachStatement;
import edu.ustb.sei.mde.xmu2.statement.PatternCaseClause;
import edu.ustb.sei.mde.xmu2.statement.RuleCallStatement;
import edu.ustb.sei.mde.xmu2.statement.Skip;
import edu.ustb.sei.mde.xmu2.statement.StatementPackage;
import edu.ustb.sei.mde.xmu2.statement.SwitchStatement;
import edu.ustb.sei.mde.xmu2.statement.UpdateClause;
import edu.ustb.sei.mde.xmu2.statement.UpdateStatement;
import edu.ustb.sei.mde.xmu2common.Xmu2commonPackage;
import edu.ustb.sei.mde.xmuxtext.services.Xmu2GrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class Xmu2SemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private Xmu2GrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ExpressionPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case ExpressionPackage.BOOLEAN_AND_EXPRESSION:
				sequence_BooleanAndExpression(context, (BooleanAndExpression) semanticObject); 
				return; 
			case ExpressionPackage.BOOLEAN_LITERAL_EXPRESSION:
				sequence_BooleanLiteralExpression(context, (BooleanLiteralExpression) semanticObject); 
				return; 
			case ExpressionPackage.BOOLEAN_OR_EXPRESSION:
				sequence_BooleanOrExpression(context, (BooleanOrExpression) semanticObject); 
				return; 
			case ExpressionPackage.EMPTY_EXPRESSION:
				sequence_EmptyExpression(context, (EmptyExpression) semanticObject); 
				return; 
			case ExpressionPackage.ENUM_LITERAL_EXPRESSION:
				sequence_EnumLiteralExpression(context, (EnumLiteralExpression) semanticObject); 
				return; 
			case ExpressionPackage.FEATURE_PATH:
				sequence_FeaturePath(context, (FeaturePath) semanticObject); 
				return; 
			case ExpressionPackage.INTEGER_LITERAL_EXPRESSION:
				sequence_IntegerLiteralExpression(context, (IntegerLiteralExpression) semanticObject); 
				return; 
			case ExpressionPackage.LOOP_PATH:
				sequence_LoopPath(context, (LoopPath) semanticObject); 
				return; 
			case ExpressionPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case ExpressionPackage.OBJECT_URI_EXPRESSION:
				sequence_ObjectURIExpression(context, (ObjectURIExpression) semanticObject); 
				return; 
			case ExpressionPackage.OPERATION_PATH:
				sequence_OperationPath(context, (OperationPath) semanticObject); 
				return; 
			case ExpressionPackage.PAREN_EXPRESSION:
				sequence_AtomicExpression(context, (ParenExpression) semanticObject); 
				return; 
			case ExpressionPackage.PATH_EXPRESSION:
				sequence_UnaryExpressionChild(context, (PathExpression) semanticObject); 
				return; 
			case ExpressionPackage.POSITION_PATH:
				sequence_PositionPath(context, (PositionPath) semanticObject); 
				return; 
			case ExpressionPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case ExpressionPackage.STRING_LITERAL_EXPRESSION:
				sequence_StringLiteralExpression(context, (StringLiteralExpression) semanticObject); 
				return; 
			case ExpressionPackage.UNARY_EXPRESSION:
				sequence_UnaryExpression(context, (UnaryExpression) semanticObject); 
				return; 
			case ExpressionPackage.VARIABLE_EXPRESSION:
				sequence_VariableExpression(context, (VariableExpression) semanticObject); 
				return; 
			}
		else if (epackage == PatternPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PatternPackage.OBJECT_PATTERN_EXPRESSION:
				sequence_ObjectPatternExpression(context, (ObjectPatternExpression) semanticObject); 
				return; 
			case PatternPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case PatternPackage.PATTERN_NODE:
				sequence_PatternNode(context, (PatternNode) semanticObject); 
				return; 
			case PatternPackage.PROPERTY_PATTERN_EXPRESSION:
				sequence_PropertyPatternExpression(context, (PropertyPatternExpression) semanticObject); 
				return; 
			}
		else if (epackage == StatementPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case StatementPackage.ASSIGN_STATEMENT:
				sequence_AssignStatement(context, (AssignStatement) semanticObject); 
				return; 
			case StatementPackage.BLOCK_STATEMENT:
				sequence_BlockStatement(context, (BlockStatement) semanticObject); 
				return; 
			case StatementPackage.CONCRETE_DELETE_LINK_STATEMENT:
				sequence_DeleteLinkStatement(context, (ConcreteDeleteLinkStatement) semanticObject); 
				return; 
			case StatementPackage.DEFAULT_CASE_CLAUSE:
				sequence_DefaultCaseClause(context, (DefaultCaseClause) semanticObject); 
				return; 
			case StatementPackage.DELETE_NODE_STATEMENT:
				sequence_DeleteNodeStatement(context, (DeleteNodeStatement) semanticObject); 
				return; 
			case StatementPackage.ENFORCE_PATTERN_STATEMENT:
				sequence_EnforcePatternStatement(context, (EnforcePatternStatement) semanticObject); 
				return; 
			case StatementPackage.EXPRESSION_CASE_CLAUSE:
				sequence_ExpressionCaseClause(context, (ExpressionCaseClause) semanticObject); 
				return; 
			case StatementPackage.FAIL:
				sequence_Fail(context, (Fail) semanticObject); 
				return; 
			case StatementPackage.FOR_EACH_STATEMENT:
				sequence_ForEachStatement(context, (ForEachStatement) semanticObject); 
				return; 
			case StatementPackage.PATTERN_CASE_CLAUSE:
				sequence_PatternCaseClause(context, (PatternCaseClause) semanticObject); 
				return; 
			case StatementPackage.RULE_CALL_STATEMENT:
				sequence_RuleCallStatement(context, (RuleCallStatement) semanticObject); 
				return; 
			case StatementPackage.SKIP:
				sequence_Skip(context, (Skip) semanticObject); 
				return; 
			case StatementPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case StatementPackage.UPDATE_CLAUSE:
				sequence_UpdateClause(context, (UpdateClause) semanticObject); 
				return; 
			case StatementPackage.UPDATE_STATEMENT:
				sequence_UpdateStatement(context, (UpdateStatement) semanticObject); 
				return; 
			}
		else if (epackage == Xmu2Package.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case Xmu2Package.ARITHMETIC_RULE:
				sequence_ArithmeticRule(context, (ArithmeticRule) semanticObject); 
				return; 
			case Xmu2Package.CONCRETE_VARIABLE_DECLARATION:
				sequence_ConcreteVariableDeclaration(context, (ConcreteVariableDeclaration) semanticObject); 
				return; 
			case Xmu2Package.ENTRY_DATA:
				sequence_EntryData(context, (EntryData) semanticObject); 
				return; 
			case Xmu2Package.ENTRY_POINT:
				sequence_EntryPoint(context, (EntryPoint) semanticObject); 
				return; 
			case Xmu2Package.MODEL_RULE:
				sequence_ModelRule(context, (ModelRule) semanticObject); 
				return; 
			case Xmu2Package.PARAMETER:
				sequence_Parameter(context, (edu.ustb.sei.mde.xmu2.Parameter) semanticObject); 
				return; 
			case Xmu2Package.REFLECTIVE_VARIABLE_DECLARATION:
				sequence_ReflectiveVariableDeclaration(context, (ReflectiveVariableDeclaration) semanticObject); 
				return; 
			case Xmu2Package.TRANSFORMATION_MODEL:
				sequence_TransformationModel(context, (TransformationModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AdditiveExpression returns AdditiveExpression
	 *     RelationalExpressionChild returns AdditiveExpression
	 *     BooleanAndExpressionChild returns AdditiveExpression
	 *     BooleanOrExpressionChild returns AdditiveExpression
	 *     Expression returns AdditiveExpression
	 *
	 * Constraint:
	 *     (operands+=AdditiveExpressionChild (operators+=AdditiveOperator operands+=AdditiveExpressionChild)+)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractRule returns ArithmeticRule
	 *     ArithmeticRule returns ArithmeticRule
	 *
	 * Constraint:
	 *     (name=NAME (parameters+=Parameter parameters+=Parameter*)? statements+=Statement*)
	 */
	protected void sequence_ArithmeticRule(ISerializationContext context, ArithmeticRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignStatement returns AssignStatement
	 *     Statement returns AssignStatement
	 *
	 * Constraint:
	 *     (updatedVariable=VariableExpression value=Expression)
	 */
	protected void sequence_AssignStatement(ISerializationContext context, AssignStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.ASSIGN_STATEMENT__UPDATED_VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.ASSIGN_STATEMENT__UPDATED_VARIABLE));
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.ASSIGN_STATEMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.ASSIGN_STATEMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignStatementAccess().getUpdatedVariableVariableExpressionParserRuleCall_0_0(), semanticObject.getUpdatedVariable());
		feeder.accept(grammarAccess.getAssignStatementAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnaryExpressionChild returns ParenExpression
	 *     UnaryExpressionChild.PathExpression_1_0 returns ParenExpression
	 *     AtomicExpression returns ParenExpression
	 *     MultiplicativeExpressionChild returns ParenExpression
	 *     AdditiveExpressionChild returns ParenExpression
	 *     RelationalExpressionChild returns ParenExpression
	 *     BooleanAndExpressionChild returns ParenExpression
	 *     BooleanOrExpressionChild returns ParenExpression
	 *     Expression returns ParenExpression
	 *
	 * Constraint:
	 *     body=Expression
	 */
	protected void sequence_AtomicExpression(ISerializationContext context, ParenExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.PAREN_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.PAREN_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicExpressionAccess().getBodyExpressionParserRuleCall_0_2_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BlockStatement returns BlockStatement
	 *     Statement returns BlockStatement
	 *
	 * Constraint:
	 *     (body+=Statement body+=Statement*)?
	 */
	protected void sequence_BlockStatement(ISerializationContext context, BlockStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanAndExpression returns BooleanAndExpression
	 *     BooleanOrExpressionChild returns BooleanAndExpression
	 *     Expression returns BooleanAndExpression
	 *
	 * Constraint:
	 *     (operands+=BooleanAndExpressionChild operands+=BooleanAndExpressionChild+)
	 */
	protected void sequence_BooleanAndExpression(ISerializationContext context, BooleanAndExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanLiteralExpression returns BooleanLiteralExpression
	 *     UnaryExpressionChild returns BooleanLiteralExpression
	 *     UnaryExpressionChild.PathExpression_1_0 returns BooleanLiteralExpression
	 *     AtomicExpression returns BooleanLiteralExpression
	 *     ConstantExpression returns BooleanLiteralExpression
	 *     MultiplicativeExpressionChild returns BooleanLiteralExpression
	 *     AdditiveExpressionChild returns BooleanLiteralExpression
	 *     RelationalExpressionChild returns BooleanLiteralExpression
	 *     BooleanAndExpressionChild returns BooleanLiteralExpression
	 *     BooleanOrExpressionChild returns BooleanLiteralExpression
	 *     Expression returns BooleanLiteralExpression
	 *
	 * Constraint:
	 *     value=BOOLEAN
	 */
	protected void sequence_BooleanLiteralExpression(ISerializationContext context, BooleanLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.BOOLEAN_LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanLiteralExpressionAccess().getValueBOOLEANTerminalRuleCall_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanOrExpression returns BooleanOrExpression
	 *     Expression returns BooleanOrExpression
	 *
	 * Constraint:
	 *     (operands+=BooleanOrExpressionChild operands+=BooleanOrExpressionChild+)
	 */
	protected void sequence_BooleanOrExpression(ISerializationContext context, BooleanOrExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConcreteVariableDeclaration returns ConcreteVariableDeclaration
	 *
	 * Constraint:
	 *     (name=NAME type=[EClassifier|Type])
	 */
	protected void sequence_ConcreteVariableDeclaration(ISerializationContext context, ConcreteVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Xmu2commonPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Xmu2commonPackage.Literals.NAMED_ELEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, Xmu2Package.Literals.TYPED_ELEMENT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Xmu2Package.Literals.TYPED_ELEMENT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConcreteVariableDeclarationAccess().getNameNAMETerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getConcreteVariableDeclarationAccess().getTypeEClassifierTypeParserRuleCall_2_0_1(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseClause returns DefaultCaseClause
	 *     DefaultCaseClause returns DefaultCaseClause
	 *
	 * Constraint:
	 *     action=Statement
	 */
	protected void sequence_DefaultCaseClause(ISerializationContext context, DefaultCaseClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.CASE_CLAUSE__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.CASE_CLAUSE__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefaultCaseClauseAccess().getActionStatementParserRuleCall_2_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeleteLinkStatement returns ConcreteDeleteLinkStatement
	 *     Statement returns ConcreteDeleteLinkStatement
	 *
	 * Constraint:
	 *     (source=VariableExpression feature=NAME target=Expression)
	 */
	protected void sequence_DeleteLinkStatement(ISerializationContext context, ConcreteDeleteLinkStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.DELETE_LINK_STATEMENT__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.DELETE_LINK_STATEMENT__SOURCE));
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.DELETE_LINK_STATEMENT__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.DELETE_LINK_STATEMENT__FEATURE));
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.DELETE_LINK_STATEMENT__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.DELETE_LINK_STATEMENT__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteLinkStatementAccess().getSourceVariableExpressionParserRuleCall_2_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getDeleteLinkStatementAccess().getFeatureNAMETerminalRuleCall_4_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getDeleteLinkStatementAccess().getTargetExpressionParserRuleCall_6_0(), semanticObject.getTarget());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeleteNodeStatement returns DeleteNodeStatement
	 *     Statement returns DeleteNodeStatement
	 *
	 * Constraint:
	 *     node=VariableExpression
	 */
	protected void sequence_DeleteNodeStatement(ISerializationContext context, DeleteNodeStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.DELETE_NODE_STATEMENT__NODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.DELETE_NODE_STATEMENT__NODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteNodeStatementAccess().getNodeVariableExpressionParserRuleCall_1_0(), semanticObject.getNode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EmptyExpression returns EmptyExpression
	 *     UnaryExpressionChild returns EmptyExpression
	 *     UnaryExpressionChild.PathExpression_1_0 returns EmptyExpression
	 *     AtomicExpression returns EmptyExpression
	 *     ConstantExpression returns EmptyExpression
	 *     MultiplicativeExpressionChild returns EmptyExpression
	 *     AdditiveExpressionChild returns EmptyExpression
	 *     RelationalExpressionChild returns EmptyExpression
	 *     BooleanAndExpressionChild returns EmptyExpression
	 *     BooleanOrExpressionChild returns EmptyExpression
	 *     Expression returns EmptyExpression
	 *
	 * Constraint:
	 *     type=EmptyValue
	 */
	protected void sequence_EmptyExpression(ISerializationContext context, EmptyExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.EMPTY_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.EMPTY_EXPRESSION__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEmptyExpressionAccess().getTypeEmptyValueEnumRuleCall_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EnforcePatternStatement returns EnforcePatternStatement
	 *     Statement returns EnforcePatternStatement
	 *
	 * Constraint:
	 *     pattern=Pattern
	 */
	protected void sequence_EnforcePatternStatement(ISerializationContext context, EnforcePatternStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.ENFORCE_PATTERN_STATEMENT__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.ENFORCE_PATTERN_STATEMENT__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnforcePatternStatementAccess().getPatternPatternParserRuleCall_1_0(), semanticObject.getPattern());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     EntryData returns EntryData
	 *
	 * Constraint:
	 *     (tag=Tag? index=INT fragment=OBJ_URI?)
	 */
	protected void sequence_EntryData(ISerializationContext context, EntryData semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EntryPoint returns EntryPoint
	 *
	 * Constraint:
	 *     (rule=[ModelRule|NAME] parameters+=EntryData parameters+=EntryData*)
	 */
	protected void sequence_EntryPoint(ISerializationContext context, EntryPoint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumLiteralExpression returns EnumLiteralExpression
	 *     UnaryExpressionChild returns EnumLiteralExpression
	 *     UnaryExpressionChild.PathExpression_1_0 returns EnumLiteralExpression
	 *     AtomicExpression returns EnumLiteralExpression
	 *     ConstantExpression returns EnumLiteralExpression
	 *     MultiplicativeExpressionChild returns EnumLiteralExpression
	 *     AdditiveExpressionChild returns EnumLiteralExpression
	 *     RelationalExpressionChild returns EnumLiteralExpression
	 *     BooleanAndExpressionChild returns EnumLiteralExpression
	 *     BooleanOrExpressionChild returns EnumLiteralExpression
	 *     Expression returns EnumLiteralExpression
	 *
	 * Constraint:
	 *     (type=[EEnum|Type] value=[EEnumLiteral|NAME])
	 */
	protected void sequence_EnumLiteralExpression(ISerializationContext context, EnumLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.ENUM_LITERAL_EXPRESSION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.ENUM_LITERAL_EXPRESSION__TYPE));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.ENUM_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.ENUM_LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumLiteralExpressionAccess().getTypeEEnumTypeParserRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getEnumLiteralExpressionAccess().getValueEEnumLiteralNAMETerminalRuleCall_2_0_1(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseClause returns ExpressionCaseClause
	 *     ExpressionCaseClause returns ExpressionCaseClause
	 *
	 * Constraint:
	 *     (condition=Expression action=Statement)
	 */
	protected void sequence_ExpressionCaseClause(ISerializationContext context, ExpressionCaseClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.EXPRESSION_CASE_CLAUSE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.EXPRESSION_CASE_CLAUSE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.CASE_CLAUSE__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.CASE_CLAUSE__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionCaseClauseAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getExpressionCaseClauseAccess().getActionStatementParserRuleCall_3_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fail returns Fail
	 *     Statement returns Fail
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_Fail(ISerializationContext context, Fail semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FeaturePath returns FeaturePath
	 *     Path returns FeaturePath
	 *
	 * Constraint:
	 *     feature=NAME
	 */
	protected void sequence_FeaturePath(ISerializationContext context, FeaturePath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.FEATURE_PATH__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.FEATURE_PATH__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeaturePathAccess().getFeatureNAMETerminalRuleCall_1_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ForEachStatement returns ForEachStatement
	 *     Statement returns ForEachStatement
	 *
	 * Constraint:
	 *     (pattern=Pattern action=Statement)
	 */
	protected void sequence_ForEachStatement(ISerializationContext context, ForEachStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.FOR_EACH_STATEMENT__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.FOR_EACH_STATEMENT__PATTERN));
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.FOR_EACH_STATEMENT__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.FOR_EACH_STATEMENT__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForEachStatementAccess().getPatternPatternParserRuleCall_1_0(), semanticObject.getPattern());
		feeder.accept(grammarAccess.getForEachStatementAccess().getActionStatementParserRuleCall_3_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IntegerLiteralExpression returns IntegerLiteralExpression
	 *     UnaryExpressionChild returns IntegerLiteralExpression
	 *     UnaryExpressionChild.PathExpression_1_0 returns IntegerLiteralExpression
	 *     AtomicExpression returns IntegerLiteralExpression
	 *     ConstantExpression returns IntegerLiteralExpression
	 *     MultiplicativeExpressionChild returns IntegerLiteralExpression
	 *     AdditiveExpressionChild returns IntegerLiteralExpression
	 *     RelationalExpressionChild returns IntegerLiteralExpression
	 *     BooleanAndExpressionChild returns IntegerLiteralExpression
	 *     BooleanOrExpressionChild returns IntegerLiteralExpression
	 *     Expression returns IntegerLiteralExpression
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_IntegerLiteralExpression(ISerializationContext context, IntegerLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.INTEGER_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.INTEGER_LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntegerLiteralExpressionAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LoopPath returns LoopPath
	 *     Path returns LoopPath
	 *
	 * Constraint:
	 *     (operator=LoopOperator variable=ConcreteVariableDeclaration body=Expression)
	 */
	protected void sequence_LoopPath(ISerializationContext context, LoopPath semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LOOP_PATH__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LOOP_PATH__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LOOP_PATH__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LOOP_PATH__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.LOOP_PATH__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.LOOP_PATH__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoopPathAccess().getOperatorLoopOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getLoopPathAccess().getVariableConcreteVariableDeclarationParserRuleCall_3_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getLoopPathAccess().getBodyExpressionParserRuleCall_5_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractRule returns ModelRule
	 *     ModelRule returns ModelRule
	 *
	 * Constraint:
	 *     (name=NAME (parameters+=Parameter parameters+=Parameter*)? variableDeclarations+=ConcreteVariableDeclaration* statement=Statement?)
	 */
	protected void sequence_ModelRule(ISerializationContext context, ModelRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *     AdditiveExpressionChild returns MultiplicativeExpression
	 *     RelationalExpressionChild returns MultiplicativeExpression
	 *     BooleanAndExpressionChild returns MultiplicativeExpression
	 *     BooleanOrExpressionChild returns MultiplicativeExpression
	 *     Expression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (operands+=MultiplicativeExpressionChild (operators+=MultiplicativeOperator operands+=MultiplicativeExpressionChild)+)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternExpression returns ObjectPatternExpression
	 *     ObjectPatternExpression returns ObjectPatternExpression
	 *
	 * Constraint:
	 *     (feature=[EStructuralFeature|NAME] selector=LoopPath? position=PositionPath? nullable?='?'? targetNode=PatternNode)
	 */
	protected void sequence_ObjectPatternExpression(ISerializationContext context, ObjectPatternExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObjectURIExpression returns ObjectURIExpression
	 *     UnaryExpressionChild returns ObjectURIExpression
	 *     UnaryExpressionChild.PathExpression_1_0 returns ObjectURIExpression
	 *     AtomicExpression returns ObjectURIExpression
	 *     ConstantExpression returns ObjectURIExpression
	 *     MultiplicativeExpressionChild returns ObjectURIExpression
	 *     AdditiveExpressionChild returns ObjectURIExpression
	 *     RelationalExpressionChild returns ObjectURIExpression
	 *     BooleanAndExpressionChild returns ObjectURIExpression
	 *     BooleanOrExpressionChild returns ObjectURIExpression
	 *     Expression returns ObjectURIExpression
	 *
	 * Constraint:
	 *     object=[EObject|OBJ_URI]
	 */
	protected void sequence_ObjectURIExpression(ISerializationContext context, ObjectURIExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.OBJECT_URI_EXPRESSION__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.OBJECT_URI_EXPRESSION__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjectURIExpressionAccess().getObjectEObjectOBJ_URITerminalRuleCall_0_1(), semanticObject.getObject());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OperationPath returns OperationPath
	 *     Path returns OperationPath
	 *
	 * Constraint:
	 *     (operation=NAME (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_OperationPath(ISerializationContext context, OperationPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (tag=Tag? name=NAME type=[EClassifier|Type])
	 */
	protected void sequence_Parameter(ISerializationContext context, edu.ustb.sei.mde.xmu2.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CaseClause returns PatternCaseClause
	 *     PatternCaseClause returns PatternCaseClause
	 *
	 * Constraint:
	 *     (condition=Pattern action=Statement)
	 */
	protected void sequence_PatternCaseClause(ISerializationContext context, PatternCaseClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.PATTERN_CASE_CLAUSE__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.PATTERN_CASE_CLAUSE__CONDITION));
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.CASE_CLAUSE__ACTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.CASE_CLAUSE__ACTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPatternCaseClauseAccess().getConditionPatternParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getPatternCaseClauseAccess().getActionStatementParserRuleCall_3_0(), semanticObject.getAction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PatternNode returns PatternNode
	 *
	 * Constraint:
	 *     (variable=ConcreteVariableDeclaration (expressions+=PatternExpression expressions+=PatternExpression*)?)
	 */
	protected void sequence_PatternNode(ISerializationContext context, PatternNode semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (root=PatternNode guard=Expression?)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PositionPath returns PositionPath
	 *     Path returns PositionPath
	 *
	 * Constraint:
	 *     (type=PositionOperator value=Expression?)
	 */
	protected void sequence_PositionPath(ISerializationContext context, PositionPath semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PatternExpression returns PropertyPatternExpression
	 *     PropertyPatternExpression returns PropertyPatternExpression
	 *
	 * Constraint:
	 *     (feature=[EStructuralFeature|NAME] selector=LoopPath? position=PositionPath? nullable?='?'? targetExpression=Expression)
	 */
	protected void sequence_PropertyPatternExpression(ISerializationContext context, PropertyPatternExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReflectiveVariableDeclaration returns ReflectiveVariableDeclaration
	 *
	 * Constraint:
	 *     name=NAME
	 */
	protected void sequence_ReflectiveVariableDeclaration(ISerializationContext context, ReflectiveVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, Xmu2commonPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, Xmu2commonPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReflectiveVariableDeclarationAccess().getNameNAMETerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RelationalExpression returns RelationalExpression
	 *     BooleanAndExpressionChild returns RelationalExpression
	 *     BooleanOrExpressionChild returns RelationalExpression
	 *     Expression returns RelationalExpression
	 *
	 * Constraint:
	 *     (left=RelationalExpressionChild operator=RelationalOperator right=RelationalExpressionChild)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.RELATIONAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.RELATIONAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.RELATIONAL_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.RELATIONAL_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.RELATIONAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.RELATIONAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getLeftRelationalExpressionChildParserRuleCall_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getOperatorRelationalOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getRightRelationalExpressionChildParserRuleCall_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleCallStatement returns RuleCallStatement
	 *     Statement returns RuleCallStatement
	 *
	 * Constraint:
	 *     (rule=[AbstractRule|NAME] (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_RuleCallStatement(ISerializationContext context, RuleCallStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Skip returns Skip
	 *     Statement returns Skip
	 *
	 * Constraint:
	 *     {Skip}
	 */
	protected void sequence_Skip(ISerializationContext context, Skip semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringLiteralExpression returns StringLiteralExpression
	 *     UnaryExpressionChild returns StringLiteralExpression
	 *     UnaryExpressionChild.PathExpression_1_0 returns StringLiteralExpression
	 *     AtomicExpression returns StringLiteralExpression
	 *     ConstantExpression returns StringLiteralExpression
	 *     MultiplicativeExpressionChild returns StringLiteralExpression
	 *     AdditiveExpressionChild returns StringLiteralExpression
	 *     RelationalExpressionChild returns StringLiteralExpression
	 *     BooleanAndExpressionChild returns StringLiteralExpression
	 *     BooleanOrExpressionChild returns StringLiteralExpression
	 *     Expression returns StringLiteralExpression
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteralExpression(ISerializationContext context, StringLiteralExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.STRING_LITERAL_EXPRESSION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.STRING_LITERAL_EXPRESSION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpressionAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SwitchStatement returns SwitchStatement
	 *     Statement returns SwitchStatement
	 *
	 * Constraint:
	 *     (root=VariableExpression cases+=CaseClause+)
	 */
	protected void sequence_SwitchStatement(ISerializationContext context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransformationModel returns TransformationModel
	 *
	 * Constraint:
	 *     (name=NAME packages+=[EPackage|MODEL_URI]* entryPoints+=EntryPoint* rules+=AbstractRule*)
	 */
	protected void sequence_TransformationModel(ISerializationContext context, TransformationModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryExpressionChild returns PathExpression
	 *     MultiplicativeExpressionChild returns PathExpression
	 *     AdditiveExpressionChild returns PathExpression
	 *     RelationalExpressionChild returns PathExpression
	 *     BooleanAndExpressionChild returns PathExpression
	 *     BooleanOrExpressionChild returns PathExpression
	 *     Expression returns PathExpression
	 *
	 * Constraint:
	 *     (host=UnaryExpressionChild_PathExpression_1_0 path+=Path path+=Path*)
	 */
	protected void sequence_UnaryExpressionChild(ISerializationContext context, PathExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnaryExpression returns UnaryExpression
	 *     MultiplicativeExpressionChild returns UnaryExpression
	 *     AdditiveExpressionChild returns UnaryExpression
	 *     RelationalExpressionChild returns UnaryExpression
	 *     BooleanAndExpressionChild returns UnaryExpression
	 *     BooleanOrExpressionChild returns UnaryExpression
	 *     Expression returns UnaryExpression
	 *
	 * Constraint:
	 *     (operator=UnaryOperator body=UnaryExpressionChild)
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, UnaryExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.UNARY_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.UNARY_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.UNARY_EXPRESSION__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.UNARY_EXPRESSION__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getOperatorUnaryOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getBodyUnaryExpressionChildParserRuleCall_1_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UpdateClause returns UpdateClause
	 *
	 * Constraint:
	 *     (type=ActionType statement=Statement)
	 */
	protected void sequence_UpdateClause(ISerializationContext context, UpdateClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.UPDATE_CLAUSE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.UPDATE_CLAUSE__TYPE));
			if (transientValues.isValueTransient(semanticObject, StatementPackage.Literals.UPDATE_CLAUSE__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, StatementPackage.Literals.UPDATE_CLAUSE__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUpdateClauseAccess().getTypeActionTypeEnumRuleCall_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getUpdateClauseAccess().getStatementStatementParserRuleCall_2_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UpdateStatement returns UpdateStatement
	 *     Statement returns UpdateStatement
	 *
	 * Constraint:
	 *     (source=Pattern view=Pattern clauses+=UpdateClause+)
	 */
	protected void sequence_UpdateStatement(ISerializationContext context, UpdateStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableExpression returns VariableExpression
	 *     UnaryExpressionChild returns VariableExpression
	 *     UnaryExpressionChild.PathExpression_1_0 returns VariableExpression
	 *     AtomicExpression returns VariableExpression
	 *     MultiplicativeExpressionChild returns VariableExpression
	 *     AdditiveExpressionChild returns VariableExpression
	 *     RelationalExpressionChild returns VariableExpression
	 *     BooleanAndExpressionChild returns VariableExpression
	 *     BooleanOrExpressionChild returns VariableExpression
	 *     Expression returns VariableExpression
	 *
	 * Constraint:
	 *     variable=NAME
	 */
	protected void sequence_VariableExpression(ISerializationContext context, VariableExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ExpressionPackage.Literals.VARIABLE_EXPRESSION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ExpressionPackage.Literals.VARIABLE_EXPRESSION__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableExpressionAccess().getVariableNAMETerminalRuleCall_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
}
