// automatically generated by Xtext
grammar edu.ustb.sei.mde.xmuxtext.Xmu2 hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/edu.ustb.sei.mde.xmu2/metamodel/xmu2.ecore" as xmu2
import "platform:/resource/edu.ustb.sei.mde.xmu2/metamodel/xmu2.ecore#//expression" as xmu2expression
import "platform:/resource/edu.ustb.sei.mde.xmu2/metamodel/xmu2.ecore#//statement" as xmu2statement
import "platform:/resource/edu.ustb.sei.mde.xmu2/metamodel/xmu2.ecore#//pattern" as xmu2pattern
import "platform:/resource/edu.ustb.sei.mde.xmu2/metamodel/xmu2common.ecore" as xmu2common

TransformationModel returns xmu2::TransformationModel:
	{xmu2::TransformationModel}
	'module' name=NAME
	('import' packages+=[ecore::EPackage|MODEL_URI])*
	entryPoints+=EntryPoint*
	rules+=AbstractRule*
;

EntryPoint returns xmu2::EntryPoint :
	'entry' rule=[xmu2::ModelRule|NAME] '(' parameters+=EntryData ("," parameters+=EntryData)* ')'
;

EntryData returns xmu2::EntryData :
	(tag=Tag)? '[' index=INT (^fragment=OBJ_URI)?']'
;

enum Tag returns xmu2common::DomainTag :
	source='source' | view='view'
;

AbstractRule returns xmu2::AbstractRule :
	ArithmeticRule | ModelRule 
;

ModelRule returns xmu2::ModelRule :
	'rule' name=NAME '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '{'
	  (variableDeclarations+=ConcreteVariableDeclaration ';')*
	  statement=Statement?
	'}'
;

ArithmeticRule returns xmu2::ArithmeticRule :
	'function' name=NAME '(' (parameters+=Parameter (',' parameters+=Parameter)*)? ')' '{'
	statements+=Statement*
	'}'
;

Parameter returns xmu2::Parameter :
	tag = Tag? name=NAME ':' type=[ecore::EClassifier | Type]
;

Type returns ecore::EString : PRIMITIVE_TYPE | PATH_NAME;

ConcreteVariableDeclaration returns xmu2::ConcreteVariableDeclaration :
	name=NAME ':' type=[ecore::EClassifier | Type]
;


// pattern
Pattern returns xmu2pattern::Pattern :
	root=PatternNode ('[' guard = Expression ']')?
;

PatternNode returns xmu2pattern::PatternNode :
	{xmu2pattern::PatternNode} variable=ConcreteVariableDeclaration ('{' (expressions+=PatternExpression (',' expressions+=PatternExpression)*)? '}')?
//	| {xmu2pattern::ReflectivePatternNode} variable=ReflectiveVariableDeclaration '[' resolve?='#'? reflectiveIdentifier=RelationalExpressionChild ']' ('{' (expressions+=PatternExpression (',' expressions+=PatternExpression)*)? '}')?
;

PatternExpression returns xmu2pattern::PatternExpression :
		 =>PropertyPatternExpression
		| ObjectPatternExpression 
;

ObjectPatternExpression returns xmu2pattern::ObjectPatternExpression :
	 {xmu2pattern::ObjectPatternExpression} feature=[ecore::EStructuralFeature|NAME] (selector=LoopPath)? (position=PositionPath)? '=' nullable?='?'?  targetNode=PatternNode 
//	| {xmu2pattern::ReflectiveObjectPatternExpression} =>'[' resolve?='#'? reflectiveIdentifier = RelationalExpressionChild ']' (selector=LoopPath)? (position=PositionPath)? '=' nullable?='?'? targetNode=PatternNode
;

PropertyPatternExpression returns xmu2pattern::PropertyPatternExpression :
	{xmu2pattern::PropertyPatternExpression} feature=[ecore::EStructuralFeature|NAME] (selector=LoopPath)? (position=PositionPath)? '=' nullable?='?'? targetExpression=Expression
//	| {xmu2pattern::ReflectivePropertyPatternExpression} =>'[' resolve?='#'? reflectiveIdentifier = RelationalExpressionChild ']' (selector=LoopPath)? (position=PositionPath)? '=' nullable?='?'? targetExpression=Expression
;

ReflectiveVariableDeclaration returns xmu2::ReflectiveVariableDeclaration: 
	name=NAME
;


// path

LoopPath returns xmu2expression::LoopPath :
	'->' operator = LoopOperator '(' variable = ConcreteVariableDeclaration '|' body = Expression ')'
;

PositionPath returns xmu2expression::PositionPath :
	'->' type = PositionOperator '(' value = Expression? ')'
;

FeaturePath returns xmu2expression::FeaturePath :
	'.' feature = NAME
;

OperationPath returns xmu2expression::OperationPath :
	'.' operation=NAME '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
;

enum LoopOperator returns xmu2common::LoopOperator :
	select='select' | forAll='forAll' | exists='exists'
;

enum PositionOperator returns xmu2common::PositionOperator :
	first='first' | last = 'last' | at = 'at'
;


// expression

VariableExpression returns xmu2expression::VariableExpression :
	variable = NAME
;

//PathExpression returns xmu2expression::PathExpression :
//	host = AtomicExpression (path+=Path)+
//;

Path returns xmu2expression::Path :
	=>LoopPath  
	| PositionPath 
	| =>FeaturePath 
	| OperationPath
;

EmptyExpression returns xmu2expression::EmptyExpression :
	type=EmptyValue
;

enum EmptyValue returns xmu2expression::EmptyValueType :
	nullValue = 'null' | emptyValue = 'undefined'
;

StringLiteralExpression returns xmu2expression::StringLiteralExpression :
	value = STRING
;

IntegerLiteralExpression returns xmu2expression::IntegerLiteralExpression :
	value = INT
;

BooleanLiteralExpression returns xmu2expression::BooleanLiteralExpression: 
	value = BOOLEAN
;


EnumLiteralExpression returns xmu2expression::EnumLiteralExpression: 
	type = [ecore::EEnum | Type] '::' value = [ecore::EEnumLiteral | NAME]
;

ObjectURIExpression returns xmu2expression::ObjectURIExpression: 
	object = [ecore::EObject | OBJ_URI]
;


UnaryExpression returns xmu2expression::UnaryExpression: 
	operator = UnaryOperator body = UnaryExpressionChild
;

enum UnaryOperator returns xmu2common::UnaryOperator :
	not = 'not' | minus = '-'
;

UnaryExpressionChild returns xmu2expression::UnaryExpressionChild: 
	AtomicExpression ({xmu2expression::PathExpression.host = current} path+=Path (path+=Path)*)?
;

AtomicExpression returns xmu2expression::AtomicExpression: 
	 '(' {xmu2expression::ParenExpression} body = Expression ')'
	| VariableExpression | ConstantExpression
;

ConstantExpression returns xmu2expression::ConstantExpression: 
	EmptyExpression | StringLiteralExpression 
	| IntegerLiteralExpression | BooleanLiteralExpression 
	| EnumLiteralExpression | ObjectURIExpression
;

MultiplicativeExpression returns xmu2expression::MultiplicativeExpression: 
	operands += MultiplicativeExpressionChild (operators+=MultiplicativeOperator operands += MultiplicativeExpressionChild)+
;

enum MultiplicativeOperator returns xmu2common::MultiplicativeOperator:
	mul = '*' | div = '/' 
;

MultiplicativeExpressionChild returns xmu2expression::MultiplicativeExpressionChild: 
	=>UnaryExpression 
	| UnaryExpressionChild
;

AdditiveExpression returns xmu2expression::AdditiveExpression: 
	operands+= AdditiveExpressionChild ( operators+=AdditiveOperator operands += AdditiveExpressionChild)+
;

enum AdditiveOperator returns xmu2common::AdditiveOperator: 
	add = '+' | sub = '-' | append = '++'
;

AdditiveExpressionChild returns xmu2expression::AdditiveExpressionChild:
	 =>MultiplicativeExpression 
	 | MultiplicativeExpressionChild
;

RelationalExpression returns xmu2expression::RelationalExpression: 
	left = RelationalExpressionChild operator=RelationalOperator right = RelationalExpressionChild
;

RelationalExpressionChild returns xmu2expression::RelationalExpressionChild:
	=>AdditiveExpression 
	| AdditiveExpressionChild
;

enum RelationalOperator returns xmu2common::RelationalOperator: 
	equal = '=' | less = '<' | lessEqual = '<=' | greater = '>' | greaterEqual = '>='
;

BooleanAndExpression returns xmu2expression::BooleanAndExpression: 
	operands += BooleanAndExpressionChild ('and' operands += BooleanAndExpressionChild)+
;

BooleanAndExpressionChild returns xmu2expression::BooleanAndExpressionChild: 
	=>RelationalExpression 
	| RelationalExpressionChild
;

BooleanOrExpression returns xmu2expression::BooleanOrExpression: 
	operands += BooleanOrExpressionChild ('or' operands += BooleanOrExpressionChild)+
;

BooleanOrExpressionChild returns xmu2expression::BooleanOrExpressionChild: 
	=>BooleanAndExpression 
	| BooleanAndExpressionChild
;

Expression returns xmu2expression::Expression :
=>BooleanOrExpression
| BooleanOrExpressionChild 
;

// statement
BlockStatement returns xmu2statement::BlockStatement: 
	{xmu2statement::BlockStatement} '{' (body += Statement (';' body += Statement)*)? '}'
;

UpdateStatement returns xmu2statement::UpdateStatement: 
	'update' source=Pattern 'with' view=Pattern 'by' (clauses+=UpdateClause)+
;

UpdateClause returns xmu2statement::UpdateClause: 
	type=ActionType '->' statement=Statement
;

enum ActionType returns xmu2statement::ActionType :
	match = 'match' | unmatchs = 'unmatchs' | unmatchv = 'unmatchv' | default = 'default' 
;

SwitchStatement returns xmu2statement::SwitchStatement: 
	'switch' '(' root = VariableExpression ')' '{' (cases+=CaseClause)+ '}'
;

CaseClause returns xmu2statement::CaseClause: 
	PatternCaseClause | ExpressionCaseClause | DefaultCaseClause
;

PatternCaseClause returns xmu2statement::PatternCaseClause: 
	'case' condition=Pattern '->' action = Statement
;

ExpressionCaseClause returns xmu2statement::ExpressionCaseClause:
	'case' condition=Expression '->' action = Statement 
;

DefaultCaseClause returns xmu2statement::DefaultCaseClause: 
	'otherwise' '->' action=Statement
;

DeleteNodeStatement returns xmu2statement::DeleteNodeStatement: 
	'delete' node=VariableExpression
;

DeleteLinkStatement returns xmu2statement::DeleteLinkStatement: 
	{xmu2statement::ConcreteDeleteLinkStatement} 
//	'delete' source=VariableExpression '.' feature=NAME '=' target=MultiplicativeExpressionChild
	'delete' source=VariableExpression '.' feature=NAME '=' target=Expression
//	| {xmu2statement::ReflectiveDeleteLinkStatement}
//	'delete' source=VariableExpression '[' resolve?='#' reflectiveIdentifier=RelationalExpressionChild ']' '=' target=MultiplicativeExpressionChild	
;

EnforcePatternStatement returns xmu2statement::EnforcePatternStatement: 
	'enforce' pattern=Pattern
;

ForEachStatement returns xmu2statement::ForEachStatement: 
	'foreach' pattern=Pattern '->' action = Statement
;

RuleCallStatement returns xmu2statement::RuleCallStatement: 
	rule=[xmu2::AbstractRule | NAME] '(' (parameters+=Expression (',' parameters+=Expression)*)? ')'
;

Skip returns xmu2statement::Skip: 
	{xmu2statement::Skip} "skip"
;

Fail returns xmu2statement::Fail: 
	{xmu2statement::Fail} 'fail' expression=Expression?
;

AssignStatement returns xmu2statement::AssignStatement: 
	updatedVariable=VariableExpression '::=' value=Expression
;




Statement returns xmu2statement::Statement:
	BlockStatement | UpdateStatement | SwitchStatement
	| DeleteNodeStatement | DeleteLinkStatement | EnforcePatternStatement
	| ForEachStatement | RuleCallStatement
	| Skip | Fail | AssignStatement
;
















// terminals
terminal BOOLEAN returns ecore::EBoolean : 'true' | 'false';
terminal INT returns ecore::EInt: ('0'..'9')+;
terminal STRING	: 
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
		; 
terminal ML_COMMENT	: '/*' -> '*/';
terminal SL_COMMENT 	: '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS			: (' '|'\t'|'\r'|'\n')+;

terminal PRIMITIVE_TYPE : 'String'|'Boolean'|'Integer'|'OclAny'|'Resource'|'OclObject';
terminal PATH_NAME : ID '!' ID;
terminal NAME : ID ('@post')?;
terminal MODEL_URI : '<' -> '>';
terminal OBJ_URI : '@'('a'..'z'|'A'..'Z'|'0'..'9'|'_'|'/'|'\\'|'.'|':'|'#')*;
terminal fragment ID: '^'?('a'..'z'|'A'..'Z'|'_')('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
//terminal ANY_OTHER: .;

