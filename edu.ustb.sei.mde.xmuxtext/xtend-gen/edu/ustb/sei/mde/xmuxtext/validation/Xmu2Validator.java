/**
 * generated by Xtext 2.10.0
 */
package edu.ustb.sei.mde.xmuxtext.validation;

import com.google.common.base.Objects;
import edu.ustb.sei.mde.xmu2.AbstractRule;
import edu.ustb.sei.mde.xmu2.ArithmeticRule;
import edu.ustb.sei.mde.xmu2.EntryData;
import edu.ustb.sei.mde.xmu2.EntryPoint;
import edu.ustb.sei.mde.xmu2.ModelRule;
import edu.ustb.sei.mde.xmu2.Parameter;
import edu.ustb.sei.mde.xmu2.Xmu2Package;
import edu.ustb.sei.mde.xmu2.pattern.ObjectPatternExpression;
import edu.ustb.sei.mde.xmu2.pattern.PatternExpression;
import edu.ustb.sei.mde.xmu2.pattern.PatternNode;
import edu.ustb.sei.mde.xmu2.pattern.PatternPackage;
import edu.ustb.sei.mde.xmu2.statement.AssignStatement;
import edu.ustb.sei.mde.xmu2.statement.BlockStatement;
import edu.ustb.sei.mde.xmu2.statement.CaseClause;
import edu.ustb.sei.mde.xmu2.statement.Fail;
import edu.ustb.sei.mde.xmu2.statement.PatternCaseClause;
import edu.ustb.sei.mde.xmu2.statement.RuleCallStatement;
import edu.ustb.sei.mde.xmu2.statement.Statement;
import edu.ustb.sei.mde.xmu2.statement.StatementPackage;
import edu.ustb.sei.mde.xmu2.statement.SwitchStatement;
import edu.ustb.sei.mde.xmu2.util.AnalysisUtil;
import edu.ustb.sei.mde.xmu2.util.Constants;
import edu.ustb.sei.mde.xmu2common.DomainTag;
import edu.ustb.sei.mde.xmuxtext.validation.AbstractXmu2Validator;
import edu.ustb.sei.mde.xmuxtext.validation.VariableValidityContext;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EClass;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 * 
 * Migrated from ValidityChecker
 */
@SuppressWarnings("all")
public class Xmu2Validator extends AbstractXmu2Validator {
  @Check
  public void checkPatternValidity(final PatternNode r) {
    try {
      EList<PatternExpression> _expressions = r.getExpressions();
      for (final PatternExpression e : _expressions) {
        {
          EClassifier cls = r.getVariable().getType();
          if ((cls instanceof EClass)) {
            if (((!Constants.REFLECTIVE_OBJECT.getEAllStructuralFeatures().contains(e.getFeature())) && 
              (!((EClass) cls).getEAllStructuralFeatures().contains(e.getFeature())))) {
              this.error("the pattern node does not contain this feature", e, PatternPackage.Literals.PATTERN_EXPRESSION__FEATURE);
            }
          }
          if ((e instanceof ObjectPatternExpression)) {
            EStructuralFeature f = ((ObjectPatternExpression)e).getFeature();
            EClassifier tarType = ((ObjectPatternExpression) e).getTargetNode().getVariable().getType();
            boolean _isSuperTypeOf = AnalysisUtil.isSuperTypeOf(f.getEType(), tarType);
            boolean _not = (!_isSuperTypeOf);
            if (_not) {
              this.error("type inconsistency", e, PatternPackage.Literals.OBJECT_PATTERN_EXPRESSION__TARGET_NODE);
            }
          }
        }
      }
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e_1 = (Exception)_t;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public void checkStatementUsage(final AbstractRule r) {
    try {
      boolean isArithmeticRule = (r instanceof ArithmeticRule);
      TreeIterator<EObject> it = r.eAllContents();
      while (it.hasNext()) {
        {
          EObject o = it.next();
          if ((o instanceof Statement)) {
            if ((o instanceof SwitchStatement)) {
              if (isArithmeticRule) {
                EList<CaseClause> _cases = ((SwitchStatement) o).getCases();
                for (final CaseClause cc : _cases) {
                  if ((cc instanceof PatternCaseClause)) {
                    this.error("you cannot use the pattern case in a function", o, StatementPackage.Literals.SWITCH_STATEMENT__CASES);
                  }
                }
              }
            } else {
              if ((o instanceof AssignStatement)) {
                if ((isArithmeticRule == false)) {
                  this.error("you cannot use the AssignStatement in a model rule", ((AssignStatement)o).eContainer(), ((AssignStatement)o).eContainmentFeature());
                }
              } else {
                if ((o instanceof BlockStatement)) {
                } else {
                  if ((o instanceof Fail)) {
                  } else {
                    if (isArithmeticRule) {
                      this.error("you cannot use this statement in a function", ((Statement)o).eContainer(), ((Statement)o).eContainmentFeature());
                    }
                  }
                }
              }
            }
          } else {
            if ((o instanceof ObjectPatternExpression)) {
              if ((((ObjectPatternExpression) o).isNullable() && (!((ObjectPatternExpression) o).getTargetNode().getExpressions().isEmpty()))) {
                this.error("a nullable pattern node cannot have inner expressions", o, PatternPackage.Literals.OBJECT_PATTERN_EXPRESSION__TARGET_NODE);
              }
            }
          }
        }
      }
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public void checkEntryPoints(final EntryPoint ep) {
    try {
      ModelRule rule = ep.getRule();
      int _size = rule.getParameters().size();
      int _size_1 = ep.getParameters().size();
      boolean _notEquals = (_size != _size_1);
      if (_notEquals) {
        this.error("the number of parameters is incorrect", ep, Xmu2Package.Literals.ENTRY_POINT__PARAMETERS);
      } else {
        for (int i = 0; (i < rule.getParameters().size()); i++) {
          {
            Parameter fp = rule.getParameters().get(i);
            EntryData ed = ep.getParameters().get(i);
            DomainTag _tag = fp.getTag();
            DomainTag _tag_1 = ed.getTag();
            boolean _notEquals_1 = (!Objects.equal(_tag, _tag_1));
            if (_notEquals_1) {
              this.error((("the domain of the parameter " + Integer.valueOf(i)) + " is inconsistent"), ep, Xmu2Package.Literals.ENTRY_POINT__PARAMETERS, i);
            }
            DomainTag _tag_2 = fp.getTag();
            boolean _equals = Objects.equal(_tag_2, DomainTag.NORMAL);
            if (_equals) {
              this.error("the entry rule cannot own normal parameters", rule, Xmu2Package.Literals.ABSTRACT_RULE__PARAMETERS, i);
            }
          }
        }
      }
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  @Check
  public void checkVariableValidity(final AbstractRule rule) {
    VariableValidityContext con = new VariableValidityContext();
    con.collectVariableNames(rule, this);
    this.checkRuleCallValidity(rule, con);
    return;
  }
  
  public void checkRuleCallValidity(final AbstractRule rule, final VariableValidityContext cont) {
    try {
      TreeIterator<EObject> it = rule.eAllContents();
      while (it.hasNext()) {
        {
          EObject o = it.next();
          if ((o instanceof RuleCallStatement)) {
            RuleCallStatement rc = ((RuleCallStatement) o);
            AbstractRule r = rc.getRule();
            int _size = r.getParameters().size();
            int _size_1 = rc.getParameters().size();
            boolean _notEquals = (_size != _size_1);
            if (_notEquals) {
              this.error("the parameter count is inconsistent", rc, StatementPackage.Literals.RULE_CALL_STATEMENT__PARAMETERS);
            } else {
              int size = r.getParameters().size();
              for (int i = 0; (i < size); i++) {
                {
                  EObject ap = rc.getParameters().get(i);
                  Parameter fp = r.getParameters().get(i);
                  cont.checkVariableUsage(ap, this, fp.getTag());
                }
              }
            }
          }
        }
      }
    } catch (final Throwable _t) {
      if (_t instanceof Exception) {
        final Exception e = (Exception)_t;
        this.warning("validity check is not finished because of some exception", rule.eContainer(), rule.eContainmentFeature());
      } else {
        throw Exceptions.sneakyThrow(_t);
      }
    }
  }
  
  public void addError(final String s, final EObject e, final EStructuralFeature f) {
    this.error(s, e, f);
  }
  
  public void addError(final String s, final EObject e, final EStructuralFeature f, final int i) {
    this.error(s, e, f, i);
  }
  
  public void addWarning(final String s, final EObject e, final EStructuralFeature f) {
    this.warning(s, e, f);
  }
  
  public void addWarning(final String s, final EObject e, final EStructuralFeature f, final int i) {
    this.warning(s, e, f, i);
  }
}
